using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Reflection.Metadata;
using System.Reflection.PortableExecutable;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices.ComTypes;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;

namespace XmlDocMarkdown.Core
{
	internal sealed class MarkdownGenerator
	{
		public string NewLine { get; set; }

		public string SourceCodePath { get; set; }

		public XmlDocSourceCodeStyle SourceCodeStyle { get; set; }

		public string RootNamespace { get; set; }

		public string RootPageLocation { get; set; }

		public bool IncludeObsolete { get; set; }

		public bool SkipUnbrowsable { get; set; }

		public bool NamespacePages { get; set; }

		public XmlDocVisibilityLevel Visibility { get; set; }

		public IReadOnlyList<ExternalDocumentation> ExternalDocs { get; set; }

		public IReadOnlyList<NamedText> GenerateOutput(Assembly assembly, XmlDocAssembly xmlDocAssembly)
			=> DoGenerateOutput(assembly, xmlDocAssembly).ToList();

		public static string GetCodeGenComment(string assemblyName) => $"<!-- DO NOT EDIT: generated by xmldocmd for {assemblyName} -->";

		private string ActualNewLine => NewLine ?? Environment.NewLine;

		public string FrontMatter { get; internal set; }

		public bool PermalinkPretty { get; internal set; }

		private IEnumerable<NamedText> DoGenerateOutput(Assembly assembly, XmlDocAssembly xmlDocAssembly)
		{
			string extension = GetFileExtension();
			string assemblyName = assembly.GetName().Name;
			string assemblyFilePath = assembly.Modules.FirstOrDefault()?.FullyQualifiedName;
			string assemblyFileName = assemblyFilePath != null ? Path.GetFileName(assemblyFilePath) : assemblyName;

			var visibleTypes = assembly
				.DefinedTypes
				.Where(IsVisible)
				.ToList();

			var membersByXmlDocName = visibleTypes
				.Where(x => new[] { TypeKind.Class, TypeKind.Struct, TypeKind.Interface }.Contains(GetTypeKind(x)))
				.SelectMany(x => x.DeclaredMembers)
				.Where(x => !(x is TypeInfo) && IsVisible(x))
				.Concat(visibleTypes)
				.GroupBy(XmlDocUtility.GetXmlDocRef)
				.ToDictionary(x => x.Key, x => x.Single());

			var visibleTypeRecords = visibleTypes
				.Select(typeInfo => new
				{
					TypeInfo = typeInfo,
					Path = GetTypeUriName(typeInfo) + ".md",
					ShortName = GetShortName(typeInfo),
					ShortSignature = GetShortSignature(typeInfo),
					Namespace = GetNamespaceName(typeInfo),
					Visibility = GetTypeVisibility(typeInfo),
				})
				.ToList();

			var visibleNamespaceRecords = visibleTypeRecords
				.Where(x => x.TypeInfo.DeclaringType == null)
				.GroupBy(x => x.Namespace)
				.Select(ng => new
				{
					Namespace = ng.Key,
					Types = ng
						.OrderBy(x => x.ShortName, StringComparer.OrdinalIgnoreCase)
						.ThenBy(x => x.Path, StringComparer.OrdinalIgnoreCase)
						.ToList()
				})
				.OrderBy(x => x.Namespace, StringComparer.OrdinalIgnoreCase)
				.ToList();

			string sourceCodePath = SourceCodePath?.Trim('/');
			var rootPath = GetAssemblyUriName(assembly);
			var safeAssemblyName = GetSafeName(rootPath);
			string rootNamespace = RootNamespace ??
				visibleNamespaceRecords.OrderBy(x => x.Namespace.Length).ThenByDescending(x => x.Types.Count).Select(x => x.Namespace).FirstOrDefault(x => x.Length != 0);
			RootPageLocation = $"{safeAssemblyName}" + (PermalinkPretty ? "Assembly.md" : ".md");
			var context = new MarkdownContext(xmlDocAssembly, membersByXmlDocName, assemblyFileName,
				sourceCodePath, SourceCodeStyle, rootNamespace, RootPageLocation, assembly.Location);
			yield return CreateNamedText(context.PageLocation, null, assemblyName, writer =>
			{
				var front = GetFrontMatter(assemblyName, $"{safeAssemblyName}" + (PermalinkPretty ? "Assembly" : "") + extension);
				if (!string.IsNullOrEmpty(front))
				{
					writer.WriteLine(front);
				}
				writer.WriteLine($"# {assemblyName} assembly");

				foreach (var group in visibleNamespaceRecords)
				{
					writer.WriteLine();
					writer.WriteLine($"## {group.Namespace} namespace");

					foreach (var typeGroup in group.Types.GroupBy(x => x.Visibility))
					{
						writer.WriteLine();
						writer.WriteLine($"| {(typeGroup.Key == XmlDocVisibilityLevel.Public ? "public" : "internal")} type | description |");
						writer.WriteLine("| --- | --- |");
						foreach (var typeInfo in typeGroup)
						{
							string relative = GetPermalink(typeInfo.Path);
							string safeRelative = GetSafeName(relative);
							if (PermalinkPretty)
								safeRelative += "Type";
							string rel = MakeRelative(context.PageLocation, $"{GetNamespaceUriName(group.Namespace)}/{safeRelative}");
							string typeText = GetShortSignatureMarkdown(typeInfo.ShortSignature, rel);
							string summaryText = GetShortSummaryMarkdown(xmlDocAssembly, typeInfo.TypeInfo, context);
							writer.WriteLine($"| {typeText} | {summaryText} |");
						}
					}
				}

				writer.WriteLine();
				writer.WriteLine(GetCodeGenComment(assemblyFileName));
			});


			// create separate parent pages for each namespace in the assembly.
			foreach (var group in visibleNamespaceRecords)
			{
				string parentPageLocation = RootPageLocation;
				var parentContext = context;

				if (NamespacePages)
				{
					var namespacePath = group.Namespace;
					var safeNamespacePath = GetSafeName(namespacePath);
					parentPageLocation = $"{safeNamespacePath}Namespace.md";
					parentContext = new MarkdownContext(context, null, parentPageLocation);
					yield return CreateNamedText(parentPageLocation, context.PageLocation, group.Namespace, writer =>
					{
						var front = GetFrontMatter(namespacePath, $"{safeNamespacePath}Namespace");
						if (!string.IsNullOrEmpty(front))
						{
							writer.WriteLine(front);
						}

						writer.WriteLine($"## {group.Namespace} namespace");

						foreach (var typeGroup in group.Types.GroupBy(x => x.Visibility))
						{
							writer.WriteLine();
							writer.WriteLine($"| {(typeGroup.Key == XmlDocVisibilityLevel.Public ? "public" : "internal")} type | description |");
							writer.WriteLine("| --- | --- |");
							foreach (var typeInfo in typeGroup)
							{
								string relative = GetPermalink(typeInfo.Path);
								string safeRelative = GetSafeName(relative);
								if (PermalinkPretty)
									safeRelative += "Type";
								string rel = MakeRelative(context.PageLocation, $"{GetNamespaceUriName(group.Namespace)}/{safeRelative}");
								string typeText = GetShortSignatureMarkdown(typeInfo.ShortSignature, rel);
								string summaryText = GetShortSummaryMarkdown(xmlDocAssembly, typeInfo.TypeInfo, context);
								writer.WriteLine($"| {typeText} | {summaryText} |");
							}
						}

						writer.WriteLine();
						writer.WriteLine(GetCodeGenComment(assemblyFileName));
					});
				}

				foreach (var visibleTypeRecord in visibleTypeRecords)
				{
					if (visibleTypeRecord.Namespace == group.Namespace)
					{
						string relative = GetPermalink(visibleTypeRecord.Path);
						string safeRelative = GetSafeName(relative);
						if (PermalinkPretty)
							safeRelative += "Type.md";
						string typePage = $"{GetNamespaceUriName(visibleTypeRecord.Namespace)}/{safeRelative}";
						yield return WriteMemberPage(
							path: typePage,
							title: GetFullMemberName(visibleTypeRecord.TypeInfo),
							parent: parentPageLocation,
							memberInfo: visibleTypeRecord.TypeInfo,
							context: parentContext);

						var typeKind = GetTypeKind(visibleTypeRecord.TypeInfo);
						if (typeKind == TypeKind.Class || typeKind == TypeKind.Struct || typeKind == TypeKind.Interface)
						{
							var memberGroups = visibleTypeRecord.TypeInfo
								.DeclaredMembers
								.Where(x => !(x is TypeInfo) && IsVisible(x))
								.GroupBy(GetMemberUriName)
								.Select(tg => new
								{
									MemberUriName = tg.Key,
									Members = OrderMembers(tg, x => x).ToList(),
								})
								.ToList();

							foreach (var memberGroup in memberGroups)
							{
								yield return WriteMemberPage(
									path: $"{GetNamespaceUriName(visibleTypeRecord.Namespace)}/{GetTypeUriName(visibleTypeRecord.TypeInfo)}/{memberGroup.MemberUriName}.md",
									parent: typePage,
									title: memberGroup.MemberUriName,
									memberGroup: memberGroup.Members,
									context: context);
							}
						}
					}
				}
			}
		}

		private string GetFrontMatter(string title, string relativeLink)
		{
			if (string.IsNullOrEmpty(FrontMatter))
			{
				return null;
			}

			string contents = File.ReadAllText(FrontMatter);
			return contents.Replace("$title", title).Replace("$ref", relativeLink);
		}

		private NamedText CreateNamedText(string name, string parent, string title, Action<MarkdownWriter> writeTo)
		{
			using (var stringWriter = new StringWriter())
			{
				if (NewLine != null)
					stringWriter.NewLine = NewLine;

				var code = new MarkdownWriter(stringWriter);
				writeTo(code);
				return new NamedText(name, parent, title, stringWriter.ToString());
			}
		}

		private static Collection<XmlDocBlock> GetSummary(XmlDocAssembly xmlDocAssembly, MemberInfo member)
			=> GetSummary(xmlDocAssembly.FindMember(XmlDocUtility.GetXmlDocRef(member)), member);

		private static Collection<XmlDocBlock> GetSummary(XmlDocMember xmlDocMember, MemberInfo member)
		{
			var summary = xmlDocMember?.Summary;

			if (summary == null || summary.Count == 0)
			{
				var constructorInfo = member as ConstructorInfo;
				if (constructorInfo != null && !constructorInfo.IsStatic && constructorInfo.GetParameters().Length == 0)
					summary = new Collection<XmlDocBlock> { new XmlDocBlock { Inlines = { new XmlDocInline { Text = "The default constructor." } } } };
			}

			return summary;
		}

		private string GetShortSummaryMarkdown(XmlDocAssembly xmlDocAssembly, MemberInfo member, MarkdownContext context)
			=> ToMarkdown(GetSummary(xmlDocAssembly, member)?.FirstOrDefault()?.Inlines, context) ?? "";

		private static string GetAssemblyUriName(Assembly assembly) => $"{assembly.GetName().Name}";

		private static string GetNamespaceUriName(string namespaceName) => namespaceName ?? "global";

		private static string GetTypeUriName(TypeInfo typeInfo)
		{
			return GetFullTypeName(typeInfo, x =>
			{
				int genericTypeCount = x.GenericTypeParameters.Length;
				return GetShortName(x) + (genericTypeCount == 0 ? "" : $"-{genericTypeCount}");
			});
		}

		private string GetSafeTypeUriName(TypeInfo typeInfo)
		{
			var name = GetSafeName(GetTypeUriName(typeInfo));
			if (PermalinkPretty)
			{
				// Jekyll doesn't allow "Foo.md" and a folder named "Foo" containing the method markdown files.
				// So we rename the type "FooType.md" to avoid this conflict.
				name += "Type";
			}
			return name;
		}

		private string GetSafeName(string name)
		{
			if (PermalinkPretty)
			{
				return name.Replace(".", ""); // Jekyll can't handle dots in file name.
			}
			return name;
		}

		private string GetMemberUriName(MemberInfo memberInfo)
		{
			var typeInfo = memberInfo as TypeInfo;
			if (typeInfo != null)
			{
				return $"{GetSafeTypeUriName(typeInfo)}";
			}
			else
			{
				return GetShortName(memberInfo);
			}
		}

		private static string GetShortSignatureMarkdown(ShortSignature shortSignature, string path)
			=> EscapeHtml($"{shortSignature.Prefix}[{shortSignature.Name}]({path}){shortSignature.Suffix}");

		private static string EscapeHtml(string value)
			=> value.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;").Replace("|", "&#x7C;");

		private static string SurroundCode(string value)
		{
			string backticks = new string('`', Regex.Matches(value, @"`+").Cast<Match>().Select(x => x.Length).Concat(new[] { 0 }).Max() + 1);
			return backticks + value + backticks;
		}

		private NamedText WriteMemberPage(string path, string parent, string title, MemberInfo memberInfo, MarkdownContext context)
			=> WriteMemberPage(path, parent, title, new[] { memberInfo }, context);

		private string GetFileExtension()
		{
			if (PermalinkPretty)
			{
				return string.Empty;
			}
			return ".md";
		}

		private string GetPermalink(string path)
		{
			if (PermalinkPretty)
			{
				// permalinks paths cannot end in .md
				int pos = path.LastIndexOf('.');
				if (pos > 0)
				{
					path = path.Substring(0, pos);
				}
			}
			return path.Replace("\\", "/");
		}

		private NamedText WriteMemberPage(string path, string parent, string title, IReadOnlyList<MemberInfo> memberGroup, MarkdownContext context)
		{
			string extension = GetFileExtension();

			return CreateNamedText(path, parent, title, writer =>
			{
				var relative = $"{GetPermalink(path)}";
				var front = GetFrontMatter(title, relative);
				if (!string.IsNullOrEmpty(front))
				{
					writer.WriteLine(front);
				}

				for (int memberIndex = 0; memberIndex < memberGroup.Count; memberIndex++)
				{
					var memberInfo = memberGroup[memberIndex];
					var memberContext = new MarkdownContext(context, memberInfo, path);
					var typeInfo = memberInfo as TypeInfo;
					var typeKind = typeInfo == null ? default(TypeKind?) : GetTypeKind(typeInfo);

					if (memberIndex != 0)
						writer.WriteLine();

					writer.WriteLine($"# {EscapeHtml(GetMemberHeading(memberGroup, memberIndex))}");

					var xmlDocRef = XmlDocUtility.GetXmlDocRef(memberInfo);
					var xmlDocMember = memberContext.XmlDocAssembly.FindMember(xmlDocRef);

					var summary = GetSummary(xmlDocMember, memberInfo);
					if (summary != null && summary.Count != 0)
					{
						writer.WriteLine();
						writer.WriteLines(ToMarkdown(summary, memberContext));
					}

					var seeAlsoMembers = new List<MemberInfo>();
					if (xmlDocMember != null)
					{
						foreach (var seeAlsoInfo in xmlDocMember.SeeAlso)
						{
							string xmlDocName = seeAlsoInfo.Ref;
							if (xmlDocName != null && memberContext.MembersByXmlDocName.TryGetValue(xmlDocName, out var seeAlsoMember))
								seeAlsoMembers.Add(seeAlsoMember);
						}
					}

					writer.WriteLine();
					writer.WriteLine("```csharp");
					writer.WriteLine(GetFullSignature(memberInfo, seeAlsoMembers));
					writer.WriteLine("```");

					if (xmlDocMember != null)
					{
						var typeParameters = xmlDocMember.TypeParameters;
						var parameters = xmlDocMember.Parameters;
						if (typeParameters.Count + parameters.Count > 0)
						{
							writer.WriteLine();
							writer.WriteLine("| parameter | description |");
							writer.WriteLine("| --- | --- |");
							foreach (var typeParameter in typeParameters)
							{
								string description = ToMarkdown(typeParameter.Description.FirstOrDefault()?.Inlines, memberContext) ?? "";
								writer.WriteLine($"| {typeParameter.Name} | {description} |");
							}
							foreach (var parameter in parameters)
							{
								string description = ToMarkdown(parameter.Description.FirstOrDefault()?.Inlines, memberContext) ?? "";
								writer.WriteLine($"| {parameter.Name} | {description} |");
							}
						}
					}

					if (typeKind == TypeKind.Enum)
					{
						writer.WriteLine();
						writer.WriteLine("## Values");
						writer.WriteLine();
						writer.WriteLine("| name | value | description |");
						writer.WriteLine("| --- | --- | --- |");

						bool isFlags = IsFlagsEnum(typeInfo);
						foreach (var enumValue in typeInfo.DeclaredMembers.OfType<FieldInfo>().Where(x => x.IsPublic && x.IsLiteral))
						{
							object valueObject = enumValue.GetValue(null);
							string valueText = isFlags ? "0x" + Convert.ToString(Convert.ToInt64(valueObject), 16).ToUpperInvariant() :
								Enum.GetUnderlyingType(typeInfo.AsType()) == typeof(ulong) ? Convert.ToString(Convert.ToUInt64(valueObject)) :
									Convert.ToString(Convert.ToInt64(valueObject));
							string description = GetShortSummaryMarkdown(memberContext.XmlDocAssembly, enumValue, memberContext);
							writer.WriteLine($"| {enumValue.Name} | {SurroundCode(valueText)} | {description} |");
						}
					}
					else if (typeKind == TypeKind.Class || typeKind == TypeKind.Struct || typeKind == TypeKind.Interface)
					{
						var innerMemberVisibilityGroups = typeInfo
							.DeclaredMembers
							.Where(IsVisible)
							.GroupBy(GetVisibility)
							.Select(tg => new
							{
								Visibility = tg.Key,
								Members = tg.ToList(),
							})
							.OrderByDescending(x => (int) x.Visibility);
						foreach (var innerMemberVisibilityGroup in innerMemberVisibilityGroups)
						{
							var innerMemberSignatureGroups = OrderMembers(innerMemberVisibilityGroup
								.Members
								.GroupBy(x => GetShortSignature(x))
								.Select(tg => new
								{
									ShortSignature = tg.Key,
									Members = tg.OrderBy(x => (x as TypeInfo)?.GenericTypeParameters.Length ?? 0).ToList()
								}), x => x.Members[0]).ToList();

							if (innerMemberSignatureGroups.Count != 0)
							{
								writer.WriteLine();
								switch (innerMemberVisibilityGroup.Visibility)
								{
								case XmlDocVisibilityLevel.Public:
									writer.WriteLine(typeKind == TypeKind.Interface ? "## Members" : "## Public Members");
									break;
								case XmlDocVisibilityLevel.Protected:
									writer.WriteLine("## Protected Members");
									break;
								case XmlDocVisibilityLevel.Internal:
									writer.WriteLine("## Internal Members");
									break;
								case XmlDocVisibilityLevel.Private:
									writer.WriteLine("## Private Members");
									break;
								default:
									throw new InvalidOperationException();
								}
								writer.WriteLine();
								writer.WriteLine("| name | description |");
								writer.WriteLine("| --- | --- |");

								foreach (var innerMemberGroup in innerMemberSignatureGroups)
								{
									var innerMembers = innerMemberGroup.Members;
									var firstInnerMember = innerMembers[0];
									string memberPath = firstInnerMember is TypeInfo ?
										$"{GetMemberUriName(firstInnerMember)}{extension}" :
										$"{GetTypeUriName(typeInfo)}/{GetMemberUriName(firstInnerMember)}{extension}";
									string memberText = GetShortSignatureMarkdown(innerMemberGroup.ShortSignature, memberPath);
									string summaryText = GetShortSummaryMarkdown(memberContext.XmlDocAssembly, firstInnerMember, memberContext);
									if (innerMembers.Count != 1)
										summaryText += $" ({innerMembers.Count} {GetMemberGroupNoun(innerMembers)})";

									writer.WriteLine($"| {memberText} | {summaryText} |");
								}
							}
						}
					}

					var returnValue = xmlDocMember?.ReturnValue;
					if (returnValue != null && returnValue.Count != 0)
					{
						writer.WriteLine();
						writer.WriteLine("## Return Value");
						writer.WriteLine();
						writer.WriteLines(ToMarkdown(returnValue, memberContext));
					}

					var propertyValue = xmlDocMember?.PropertyValue;
					if (propertyValue != null && propertyValue.Count != 0)
					{
						writer.WriteLine();
						writer.WriteLine("## Property Value");
						writer.WriteLine();
						writer.WriteLines(ToMarkdown(propertyValue, memberContext));
					}

					var exceptions = xmlDocMember?.Exceptions;
					if (exceptions != null && exceptions.Count != 0)
					{
						writer.WriteLine();
						writer.WriteLine("## Exceptions");
						writer.WriteLine();
						writer.WriteLine("| exception | condition |");
						writer.WriteLine("| --- | --- |");

						foreach (var exception in exceptions)
						{
							memberContext.MembersByXmlDocName.TryGetValue(exception.ExceptionTypeRef, out var exceptionMemberInfo);
							string text = exceptionMemberInfo != null ? GetShortName(exceptionMemberInfo) : XmlDocUtility.GetShortNameForXmlDocRef(exception.ExceptionTypeRef);
							string link = WrapMarkdownRefLink(text, exceptionMemberInfo, memberContext);
							writer.WriteLine($"| {link} | {ToMarkdown(exception.Condition?.FirstOrDefault()?.Inlines, memberContext) ?? ""} |");
						}
					}

					var remarks = xmlDocMember?.Remarks;
					if (remarks != null && remarks.Count != 0)
					{
						writer.WriteLine();
						writer.WriteLine("## Remarks");
						writer.WriteLine();
						writer.WriteLines(ToMarkdown(remarks, memberContext));
					}

					var examples = xmlDocMember?.Examples;
					if (examples != null && examples.Count != 0)
					{
						writer.WriteLine();
						writer.WriteLine("## Examples");
						writer.WriteLine();
						writer.WriteLines(ToMarkdown(examples, memberContext));
					}

					writer.WriteLine();
					writer.WriteLine("## See Also");
					writer.WriteLine();

					var declaringType = memberInfo.DeclaringType?.GetTypeInfo();
					string declaringTypeXmlDocName = declaringType == null ? null : XmlDocUtility.GetXmlDocRef(declaringType);
					if (declaringType != null)
						seeAlsoMembers.Add(declaringType);

					foreach (var seeAlso in seeAlsoMembers
						.Where(x => XmlDocUtility.GetXmlDocRef(x) != xmlDocRef)
						.Select(GetGenericDefinition)
						.GroupBy(XmlDocUtility.GetXmlDocRef)
						.Select(x => new { Member = x.First(), XmlDocName = x.Key })
						.OrderBy(x => x.XmlDocName == declaringTypeXmlDocName))
					{
						if (memberContext.MembersByXmlDocName.ContainsKey(seeAlso.XmlDocName) ||
							FindExternalDocumentation(seeAlso.Member) != null)
						{
							var shortSignature = GetShortSignature(seeAlso.Member, forSeeAlso: true);
							writer.WriteLine("* " + shortSignature.Prefix +
								WrapMarkdownRefLink(shortSignature.Name, seeAlso.Member, memberContext) + shortSignature.Suffix);
						}
					}

					if (NamespacePages)
					{
						string namespacePath = GetPermalink(MakeRelative(path, parent));
						writer.WriteLine("* " + $"namespace\u00A0[{GetNamespaceName(declaringType ?? typeInfo)}]({namespacePath}{extension})");

						string assemblyName = (declaringType ?? typeInfo).Assembly.GetName().Name;
						string assemblyPath = GetPermalink(MakeRelative(path, RootPageLocation));
						writer.WriteLine("* " + $"assembly\u00A0[{assemblyName}]({assemblyPath})");
					}
					else
					{
						writer.WriteLine("* " + $"namespace\u00A0[{GetNamespaceName(declaringType ?? typeInfo)}](../{(typeInfo != null ? "" : "../")}{GetAssemblyUriName((declaringType ?? typeInfo).Assembly)}{extension})");
					}

					if (typeInfo != null && declaringType == null && !string.IsNullOrEmpty(context.SourceCodePath) && !string.IsNullOrEmpty(context.RootNamespace))
					{
						var written = false;
						var mask = XmlDocSourceCodeStyle.SourceLink | XmlDocSourceCodeStyle.DebugSymbol;

						if (context.MetadataContext.PdbLoaded &&
							(context.SourceCodeStyle & mask) != 0)
						{
							// **Note** Types that have no executable code locations
							// e.g. Interfaces, enums, derived types with only
							// default constructor and inherited methods,
							// will not be found.
							// Workround -- add a marker inner type
							// Heavier weight workround -- provide an SDK with
							// an attribute that is constructed with a
							// [System.Runtime.CompilerServices.CallerFilePath]
							// argument and reflect for its value
							// There's nowhere in the .pdb format to add an
							// arbitrary type -> file mapping

							// Allow for e.g. F# modules that contain only types
							var documents = (new[] { typeInfo.FullName }).Concat(
								typeInfo.DeclaredNestedTypes.Select(t => t.FullName))
								.SelectMany(n => context.MetadataContext[n])
								.Distinct();

							foreach (var document in documents)
							{
								var fileName = Path.GetFileName(document);
								if ((context.SourceCodeStyle & XmlDocSourceCodeStyle.SourceLink) != 0
									&& context.MetadataContext.TrySourceLink(document, out var link))
								{
									writer.WriteLine($"* [{fileName}]({link})");
									written = true;
								}
								else if ((context.SourceCodeStyle & XmlDocSourceCodeStyle.DebugSymbol) != 0)
								{
									var snip = document.Substring(context.MetadataContext.PrefixLength);
									string filePath = context.SourceCodePath + snip.Replace('\\', '/');
									if (!Uri.TryCreate(filePath, UriKind.Absolute, out _))
										filePath = "../" + filePath;
									writer.WriteLine($"* [{fileName}]({filePath})");
									written = true;
								}
							}
						}

						// default to old behaviour if requested
						if (!written &&
							  (context.SourceCodeStyle & XmlDocSourceCodeStyle.TypeName) != 0)
						{
							string namespaceName = GetNamespaceName(typeInfo);
							if (namespaceName.StartsWith(context.RootNamespace, StringComparison.Ordinal))
							{
								string directoryPath = context.SourceCodePath + namespaceName.Substring(context.RootNamespace.Length).Replace('.', '/');
								if (!Uri.TryCreate(directoryPath, UriKind.Absolute, out _))
									directoryPath = "../" + directoryPath;
								string fileName = GetShortName(typeInfo) + ".cs";
								writer.WriteLine($"* [{fileName}]({directoryPath}/{fileName})");
							}
						}
					}

					if (memberIndex < memberGroup.Count - 1)
					{
						writer.WriteLine();
						writer.WriteLine("---");
					}
				}

				writer.WriteLine();
				writer.WriteLine(GetCodeGenComment(context.AssemblyFileName));
			});
		}

		private ExternalDocumentation FindExternalDocumentation(MemberInfo memberInfo)
		{
			string namespaceName = (memberInfo as TypeInfo ?? memberInfo.DeclaringType.GetTypeInfo()).Namespace;
			return ExternalDocs?.FirstOrDefault(x => x.Namespace == namespaceName);
		}

		private MemberInfo GetGenericDefinition(MemberInfo memberInfo)
		{
			var typeInfo = memberInfo as TypeInfo;
			if (typeInfo != null)
				return typeInfo.IsGenericType ? typeInfo.GetGenericTypeDefinition().GetTypeInfo() : typeInfo;

			var methodInfo = memberInfo as MethodInfo;
			if (methodInfo != null)
				return methodInfo.IsGenericMethod ? methodInfo.GetGenericMethodDefinition() : methodInfo;

			return memberInfo;
		}

		private bool IsVisible(MemberInfo memberInfo)
		{
			var visibility = GetVisibility(memberInfo);
			if (IsMorePrivateThan(visibility, Visibility))
				return false;

			if (!IncludeObsolete && memberInfo.GetCustomAttributes<ObsoleteAttribute>().Any())
				return false;

			if (memberInfo.GetCustomAttributes<CompilerGeneratedAttribute>().Any())
				return false;

			if (SkipUnbrowsable && memberInfo.GetCustomAttributes<EditorBrowsableAttribute>().Any(x => x.State == EditorBrowsableState.Never))
				return false;

			string name = memberInfo.Name;
			if (name.Length == 0 || name[0] == '<')
				return false;

			// nested types of invisible types are invisible
			if (memberInfo.DeclaringType != null && !IsVisible(memberInfo.DeclaringType))
				return false;

			if (memberInfo is TypeInfo)
				return true;

			var methodBase = memberInfo as MethodBase;
			if (methodBase == null)
				return true;

			if (memberInfo is ConstructorInfo)
				return true;

			if (!methodBase.IsSpecialName)
				return true;

			if (methodBase.Name.StartsWith("op_", StringComparison.Ordinal))
				return true;

			return false;
		}

		private static bool IsMorePrivateThan(XmlDocVisibilityLevel visibility1, XmlDocVisibilityLevel visibility2) => (int) visibility1 < (int) visibility2;

		public static XmlDocVisibilityLevel GetMostPublic(params XmlDocVisibilityLevel[] visibilityLevels) => (XmlDocVisibilityLevel) visibilityLevels.Max(x => (int) x);

		public static XmlDocVisibilityLevel GetMostPrivate(params XmlDocVisibilityLevel[] visibilityLevels) => (XmlDocVisibilityLevel) visibilityLevels.Min(x => (int) x);

		private static string GetMemberHeading(IReadOnlyList<MemberInfo> membersInfos, int index)
		{
			var heading = $"{GetFullMemberName(membersInfos[index])} {GetMemberGroupNoun(new[] { membersInfos[index] })}";
			if (membersInfos.Count > 1)
				heading += $" ({index + 1} of {membersInfos.Count})";
			return heading;
		}

		private static string GetMemberGroupNoun(IReadOnlyList<MemberInfo> memberInfos)
		{
			bool plural = memberInfos.Count != 1;

			if (memberInfos.All(x => x is ConstructorInfo))
				return plural ? "constructors" : "constructor";
			else if (memberInfos.All(x => (x as PropertyInfo)?.GetIndexParameters().Length > 0))
				return plural ? "indexers" : "indexer";
			else if (memberInfos.All(x => x is PropertyInfo))
				return plural ? "properties" : "property";
			else if (memberInfos.All(x => (x as MethodInfo)?.Name.StartsWith("op_", StringComparison.Ordinal) == true))
				return plural ? "operators" : "operator";
			else if (memberInfos.All(x => x is MethodInfo))
				return plural ? "methods" : "method";
			else if (memberInfos.All(x => x is EventInfo))
				return plural ? "events" : "event";
			else if (memberInfos.All(x => x is FieldInfo))
				return plural ? "fields" : "field";
			else if (memberInfos.All(x => x is TypeInfo))
				return GetTypeGroupNoun(memberInfos.Cast<TypeInfo>().ToList());
			else
				return plural ? "members" : "member";
		}

		private static string GetTypeGroupNoun(IReadOnlyList<TypeInfo> typeInfos)
		{
			bool plural = typeInfos.Count != 1;

			var typeKinds = typeInfos.Select(GetTypeKind).ToList();
			if (typeKinds.All(x => x == TypeKind.Class))
				return plural ? "classes" : "class";
			else if (typeKinds.All(x => x == TypeKind.Interface))
				return plural ? "interfaces" : "interface";
			else if (typeKinds.All(x => x == TypeKind.Struct))
				return plural ? "structures" : "structure";
			else if (typeKinds.All(x => x == TypeKind.Enum))
				return plural ? "enumerations" : "enumeration";
			else if (typeKinds.All(x => x == TypeKind.Delegate))
				return plural ? "delegates" : "delegate";
			else
				return plural ? "types" : "type";
		}

		private static string GetNamespaceName(TypeInfo typeInfo) => typeInfo.Namespace ?? "global";

		private static string GetMemberNamespaceName(MemberInfo memberInfo) => GetNamespaceName(memberInfo as TypeInfo ?? memberInfo.DeclaringType.GetTypeInfo());

		private static string GetShortName(MemberInfo memberInfo)
		{
			string name = memberInfo.Name;

			int tickIndex = name.IndexOf('`');
			if (tickIndex != -1)
				name = name.Substring(0, tickIndex);

			if (name == ".ctor" || name == ".cctor")
				name = GetShortName(memberInfo.DeclaringType.GetTypeInfo());
			else if (name == "op_UnaryPlus")
				name = "op_Addition";
			else if (name == "op_UnaryNegation")
				name = "op_Subtraction";

			return name;
		}

		private static string GetOperatorKeywordName(string name)
		{
			switch (name)
			{
			case "op_Addition":
				return "operator +";
			case "op_BitwiseAnd":
				return "operator &";
			case "op_BitwiseOr":
				return "operator |";
			case "op_Decrement":
				return "operator --";
			case "op_Division":
				return "operator /";
			case "op_Equality":
				return "operator ==";
			case "op_ExclusiveOr":
				return "operator ^";
			case "op_Explicit":
				return "explicit operator";
			case "op_False":
				return "operator false";
			case "op_GreaterThan":
				return "operator >";
			case "op_GreaterThanOrEqual":
				return "operator >=";
			case "op_Implicit":
				return "implicit operator";
			case "op_Increment":
				return "operator ++";
			case "op_Inequality":
				return "operator !=";
			case "op_LeftShift":
				return "operator <<";
			case "op_LessThan":
				return "operator <";
			case "op_LessThanOrEqual":
				return "operator <=";
			case "op_LogicalNot":
				return "operator !";
			case "op_Modulus":
				return "operator %";
			case "op_Multiply":
				return "operator *";
			case "op_OnesComplement":
				return "operator ~";
			case "op_RightShift":
				return "operator >>";
			case "op_Subtraction":
				return "operator -";
			case "op_True":
				return "operator true";
			case "op_UnaryNegation":
				return "operator -";
			case "op_UnaryPlus":
				return "operator +";
			default:
				return name;
			}
		}

		private static string GetFullMemberName(MemberInfo memberInfo)
		{
			var type = memberInfo as TypeInfo;
			if (type != null)
				return GetFullTypeName(type, t => GetShortName(t) + RenderShortGenericParameters(t.GenericTypeParameters));

			if (memberInfo is ConstructorInfo || (memberInfo as PropertyInfo)?.GetIndexParameters().Length > 0)
				return GetFullTypeName(memberInfo.DeclaringType.GetTypeInfo(), t => GetShortName(t) + RenderShortGenericParameters(t.GenericTypeParameters));

			string methodName = (memberInfo as MethodInfo)?.Name;
			if (methodName?.StartsWith("op_", StringComparison.Ordinal) == true)
				return GetFullTypeName(memberInfo.DeclaringType.GetTypeInfo(), t => GetShortName(t) + RenderShortGenericParameters(t.GenericTypeParameters)) + " " + methodName.Substring(3);

			return GetFullTypeName(memberInfo.DeclaringType.GetTypeInfo(), t => GetShortName(t) + RenderShortGenericParameters(t.GenericTypeParameters)) + "." +
				GetShortName(memberInfo) + RenderShortGenericParameters(GetGenericArguments(memberInfo));
		}

		private static string GetFullTypeName(TypeInfo typeInfo, Func<TypeInfo, string> render)
		{
			string name = render(typeInfo);
			if (typeInfo.DeclaringType != null)
				name = $"{GetFullTypeName(typeInfo.DeclaringType.GetTypeInfo(), render)}.{name}";
			return name;
		}

		private sealed class ShortSignature : IEquatable<ShortSignature>
		{
			public ShortSignature(string prefix, string name, string suffix)
			{
				Prefix = prefix;
				Name = name;
				Suffix = suffix;
			}

			public string Prefix { get; }

			public string Name { get; }

			public string Suffix { get; }

			public bool Equals(ShortSignature other) => other != null && other.ToString() == ToString();

			public override bool Equals(object obj) => Equals(obj as ShortSignature);

			public override int GetHashCode() => ToString().GetHashCode();

			public override string ToString() => Prefix + Name + Suffix;
		}

		private ShortSignature GetShortSignature(MemberInfo memberInfo, bool forSeeAlso = false)
		{
			string name = GetOperatorKeywordName(GetShortName(memberInfo));
			string prefix = "";
			string suffix = "";

			var typeInfo = memberInfo as TypeInfo;
			if (typeInfo != null)
			{
				name += RenderShortGenericParameters(typeInfo.GenericTypeParameters);

				switch (GetTypeKind(typeInfo))
				{
				case TypeKind.Class:
					prefix = "class ";
					break;
				case TypeKind.Interface:
					prefix = "interface ";
					break;
				case TypeKind.Struct:
					prefix = "struct ";
					break;
				case TypeKind.Enum:
					prefix = "enum ";
					break;
				case TypeKind.Delegate:
					prefix = "delegate ";
					break;
				}

				if (!forSeeAlso)
				{
					if (IsFlagsEnum(typeInfo))
						prefix = "[Flags] " + prefix;
					if (IsStatic(typeInfo))
						prefix = "static " + prefix;
					else if (IsAbstract(typeInfo))
						prefix = "abstract " + prefix;
					else if (IsVirtual(typeInfo))
						prefix = "virtual " + prefix;
					else if (IsOverride(typeInfo))
						prefix = "override " + prefix;
				}
			}
			else
			{
				var eventInfo = memberInfo as EventInfo;
				var propertyInfo = memberInfo as PropertyInfo;
				var fieldInfo = memberInfo as FieldInfo;
				var methodBase = memberInfo as MethodBase;

				if (eventInfo != null)
				{
					prefix = "event ";
					if (!forSeeAlso)
					{
						if (IsStatic(eventInfo))
							prefix = "static " + prefix;
						else if (IsAbstract(eventInfo))
							prefix = "abstract " + prefix;
						else if (IsVirtual(eventInfo))
							prefix = "virtual " + prefix;
						else if (IsOverride(eventInfo))
							prefix = "override " + prefix;
					}
				}
				else if (propertyInfo != null)
				{
					if (!forSeeAlso)
						suffix = GetPropertyGetSet(propertyInfo);

					if (forSeeAlso)
						prefix = "property ";
					else if (IsStatic(propertyInfo))
						prefix = "static ";
					else if (IsAbstract(propertyInfo))
						prefix = "abstract ";
					else if (IsVirtual(propertyInfo))
						prefix = "virtual ";
					else if (IsOverride(propertyInfo))
						prefix = "override ";
				}
				else if (fieldInfo != null)
				{
					if (forSeeAlso)
					{
						prefix = "field ";
					}
					else
					{
						if (IsConst(fieldInfo))
							prefix += "const ";
						if (IsStatic(fieldInfo))
							prefix = "static ";
						if (IsReadOnly(fieldInfo))
							prefix += "readonly ";
					}
				}
				else if (methodBase != null)
				{
					bool isOperator = methodBase.Name.StartsWith("op_", StringComparison.Ordinal);

					if (methodBase is MethodInfo)
						name += RenderShortGenericParameters(methodBase.GetGenericArguments());

					if (!forSeeAlso && !isOperator)
						suffix += methodBase.GetParameters().Length == 0 ? "()" : "(…)";

					if (forSeeAlso)
						prefix = "method ";
					else if (IsStatic(methodBase) && !isOperator)
						prefix = "static " + prefix;
					else if (IsAbstract(methodBase))
						prefix = "abstract " + prefix;
					else if (IsVirtual(methodBase))
						prefix = "virtual " + prefix;
					else if (IsOverride(methodBase))
						prefix = "override " + prefix;
				}
			}

			return new ShortSignature(prefix: prefix.Replace(' ', '\u00A0'), name: name, suffix: suffix.Replace(' ', '\u00A0'));
		}

		private string GetPropertyGetSet(PropertyInfo propertyInfo)
		{
			var getMethod = propertyInfo.GetMethod;
			var setMethod = propertyInfo.SetMethod;
			if (getMethod == null && setMethod == null)
				throw new InvalidOperationException();

			var getVisibility = getMethod == null ? XmlDocVisibilityLevel.Private : GetMethodVisibility(getMethod);
			var setVisibility = setMethod == null ? XmlDocVisibilityLevel.Private : GetMethodVisibility(setMethod);

			if (getMethod != null && (setMethod == null || IsMorePrivateThan(setVisibility, Visibility)))
				return " { get; }";
			if (getMethod == null || IsMorePrivateThan(getVisibility, Visibility))
				return " { set; }";

			if (getVisibility == setVisibility)
				return " { get; set; }";
			else if (IsMorePrivateThan(getVisibility, setVisibility))
				return $" {{ {GetAccessModifier(getMethod)} get; set; }}";
			else
				return $" {{ get; {GetAccessModifier(setMethod)} set; }}";
		}

		private string GetFullSignature(MemberInfo memberInfo, ICollection<MemberInfo> seeAlsoMembers)
		{
			var stringBuilder = new StringBuilder();
			var lineBuilder = new StringBuilder();
			var segmentBuilder = new StringBuilder();
			const int maxLineLength = 100;

			void wrapLineIfNecessary(bool hard)
			{
				const string indent = "    ";

				if (lineBuilder.Length > indent.Length && (hard || lineBuilder.Length + segmentBuilder.Length > maxLineLength))
				{
					lineBuilder.Append(ActualNewLine);
					stringBuilder.Append(lineBuilder);
					lineBuilder.Clear();

					if (!hard)
						lineBuilder.Append(indent);
				}
			}

			foreach (string part in GetFullSignatureParts(memberInfo, seeAlsoMembers))
			{
				if (part.Length == 0 || part == ActualNewLine)
				{
					wrapLineIfNecessary(false);

					lineBuilder.Append(segmentBuilder);
					segmentBuilder.Clear();

					wrapLineIfNecessary(part == ActualNewLine);
				}
				else
				{
					segmentBuilder.Append(part);
				}
			}

			wrapLineIfNecessary(false);

			lineBuilder.Append(segmentBuilder);
			stringBuilder.Append(lineBuilder);
			return stringBuilder.ToString();
		}

		private IEnumerable<string> GetFullSignatureParts(MemberInfo memberInfo, ICollection<MemberInfo> seeAlsoMembers)
		{
			var typeInfo = memberInfo as TypeInfo;
			var typeKind = typeInfo == null ? default(TypeKind?) : GetTypeKind(typeInfo);

			var obsoleteAttribute = memberInfo.GetCustomAttribute<ObsoleteAttribute>();
			if (obsoleteAttribute != null)
			{
				string message = obsoleteAttribute.Message;
				if (string.IsNullOrWhiteSpace(message))
				{
					yield return "[Obsolete]";
				}
				else
				{
					yield return "[Obsolete(";
					yield return RenderConstant(message);
					yield return ")]";
				}
				yield return ActualNewLine;
			}

			var browsableAttribute = memberInfo.GetCustomAttribute<EditorBrowsableAttribute>();
			if (browsableAttribute != null && browsableAttribute.State != EditorBrowsableState.Always)
			{
				yield return "[EditorBrowsable(";
				yield return RenderConstant(browsableAttribute.State);
				yield return ")]";
				yield return ActualNewLine;
			}

			var attributeUsage = memberInfo.GetCustomAttribute<AttributeUsageAttribute>();
			if (attributeUsage != null)
			{
				yield return "[AttributeUsage(";

				yield return RenderConstant(attributeUsage.ValidOn);

				if (!attributeUsage.Inherited)
				{
					yield return ", ";
					yield return "";
					yield return "Inherited = false";
				}

				if (attributeUsage.AllowMultiple)
				{
					yield return ", ";
					yield return "";
					yield return "AllowMultiple = true";
				}

				yield return ")]";
				yield return ActualNewLine;
			}

			if (IsFlagsEnum(memberInfo))
			{
				yield return "[Flags]";
				yield return ActualNewLine;
			}

			yield return $"{GetAccessModifier(memberInfo)} ";

			if (IsStatic(memberInfo))
				yield return "static ";
			else if (typeKind == TypeKind.Class && typeInfo.IsSealed)
				yield return "sealed ";
			else if (IsAbstract(memberInfo))
				yield return "abstract ";
			else if (IsVirtual(memberInfo))
				yield return "virtual ";
			else if (IsOverride(memberInfo))
				yield return "override ";

			if (IsConst(memberInfo))
				yield return "const ";
			if (IsReadOnly(memberInfo))
				yield return "readonly ";

			if (memberInfo is EventInfo)
				yield return "event ";

			switch (typeKind)
			{
			case TypeKind.Class:
				yield return "class ";
				break;
			case TypeKind.Interface:
				yield return "interface ";
				break;
			case TypeKind.Struct:
				yield return "struct ";
				break;
			case TypeKind.Enum:
				yield return "enum ";
				break;
			case TypeKind.Delegate:
				yield return "delegate ";
				break;
			}

			string shortName = GetOperatorKeywordName(GetShortName(memberInfo));
			if (shortName == "Item" && memberInfo is PropertyInfo)
				shortName = "this";

			bool isConversion = shortName == "explicit operator" || shortName == "implicit operator";

			var valueType = GetValueType(memberInfo)?.GetTypeInfo();
			if (valueType != null && !isConversion)
			{
				yield return RenderTypeName(valueType, seeAlsoMembers);
				yield return " ";
			}

			if (valueType != null && isConversion)
			{
				yield return shortName;
				yield return " ";
				yield return RenderTypeName(valueType, seeAlsoMembers);
			}
			else
			{
				yield return "";
				yield return shortName;
			}

			var genericParameters = GetGenericArguments(memberInfo);
			if (genericParameters.Length != 0)
				yield return RenderGenericParameters(genericParameters);

			if (typeKind == TypeKind.Class || typeKind == TypeKind.Struct || typeKind == TypeKind.Interface)
			{
				bool isFirstBase = true;
				if (typeKind == TypeKind.Class && typeInfo.BaseType != typeof(object))
				{
					yield return " : ";
					yield return "";
					yield return RenderTypeName(typeInfo.BaseType.GetTypeInfo(), seeAlsoMembers);
					isFirstBase = false;
				}

				var baseInterfaces = typeInfo.ImplementedInterfaces.Select(x => x.GetTypeInfo())
					.Where(x => x.IsPublic)
					.OrderBy(x => x.Name, StringComparer.OrdinalIgnoreCase)
					.ThenBy(x => x.IsGenericType ? x.GenericTypeArguments.Length : 0)
					.ThenBy(x => x.IsGenericType ? RenderGenericArguments(x.GenericTypeArguments) : "", StringComparer.OrdinalIgnoreCase)
					.ToList();
				var baseTypeInterfaces = typeInfo.BaseType?.GetTypeInfo().ImplementedInterfaces.Select(x => x.GetTypeInfo()).ToList();
				foreach (var baseInterface in baseInterfaces)
				{
					if (!(typeKind == TypeKind.Class && baseTypeInterfaces.Contains(baseInterface)) &&
						!baseInterfaces.Any(x => XmlDocUtility.GetXmlDocRef(x) != XmlDocUtility.GetXmlDocRef(baseInterface) && IsLessDerived(baseInterface, x)))
					{
						yield return isFirstBase ? " : " : ", ";
						yield return "";
						yield return RenderTypeName(baseInterface, seeAlsoMembers);
						isFirstBase = false;
					}
				}
			}

			if (typeKind == TypeKind.Enum && Enum.GetUnderlyingType(typeInfo.AsType()) != typeof(int))
			{
				yield return " : ";
				yield return RenderTypeName(Enum.GetUnderlyingType(typeInfo.AsType()).GetTypeInfo(), seeAlsoMembers);
			}

			ParameterInfo[] parameterInfos = null;

			var propertyInfo = memberInfo as PropertyInfo;
			if (propertyInfo != null)
			{
				parameterInfos = GetParameters(propertyInfo);
				if (parameterInfos.Length == 0)
					parameterInfos = null;
			}

			var methodInfo = memberInfo as MethodBase ?? TryGetDelegateInvoke(memberInfo);
			if (methodInfo != null)
				parameterInfos = GetParameters(methodInfo);

			if (parameterInfos != null)
			{
				yield return propertyInfo != null ? "[" : "(";
				yield return "";

				bool isFirstParameter = true;
				foreach (var (parameterInfo, index) in parameterInfos.Select((x, i) => (x, i)))
				{
					if (!isFirstParameter)
					{
						yield return ", ";
						yield return "";
					}

					if (parameterInfo.GetCustomAttributes<CallerFilePathAttribute>().Any())
						yield return "[CallerFilePath] ";
					if (parameterInfo.GetCustomAttributes<CallerLineNumberAttribute>().Any())
						yield return "[CallerLineNumber] ";
					if (parameterInfo.GetCustomAttributes<CallerMemberNameAttribute>().Any())
						yield return "[CallerMemberName] ";

					if (isFirstParameter && IsStatic(memberInfo) && memberInfo.GetCustomAttributes<ExtensionAttribute>().Any())
						yield return "this ";

					if (parameterInfo.ParameterType.IsByRef)
						yield return parameterInfo.IsOut ? "out " : "ref ";
					if (parameterInfo.GetCustomAttributes<ParamArrayAttribute>().Any())
						yield return "params ";

					yield return RenderTypeName(parameterInfo.ParameterType.GetTypeInfo(), seeAlsoMembers);

					yield return " ";
					if (IsKeyword(parameterInfo.Name))
						yield return "@";
					yield return parameterInfo.Name ?? "P_" + index.ToString(CultureInfo.InvariantCulture); // default as per ILSpy if null

					if (ParameterHasDefaultValue(parameterInfo))
					{
						yield return " = ";
						if (CanRenderParameterConstant(parameterInfo))
							yield return RenderConstant(parameterInfo.DefaultValue);
						else if (parameterInfo.ParameterType.GetTypeInfo().IsValueType || parameterInfo.ParameterType.IsGenericParameter)
							yield return $"default({RenderTypeName(parameterInfo.ParameterType.GetTypeInfo())})";
						else
							yield return "null";
					}

					isFirstParameter = false;
				}

				yield return propertyInfo != null ? "]" : ")";
			}

			if (propertyInfo != null)
				yield return GetPropertyGetSet(propertyInfo);

			foreach (var genericParameter in genericParameters)
			{
				bool isFirstPart = true;

				if (genericParameter.GetTypeInfo().GenericParameterAttributes.HasFlag(GenericParameterAttributes.ReferenceTypeConstraint))
				{
					yield return ActualNewLine;
					yield return $"    where {genericParameter.Name} : ";

					yield return "class";
					isFirstPart = false;
				}

				bool isStruct = genericParameter.GetTypeInfo().GenericParameterAttributes.HasFlag(GenericParameterAttributes.NotNullableValueTypeConstraint);
				if (isStruct)
				{
					if (isFirstPart)
					{
						yield return ActualNewLine;
						yield return $"    where {genericParameter.Name} : ";
					}
					else
					{
						yield return ", ";
					}

					yield return "struct";
					isFirstPart = false;
				}

				var genericConstraints = genericParameter.GetTypeInfo().GetGenericParameterConstraints();
				foreach (var genericConstraint in genericConstraints.Where(x => x != typeof(ValueType)))
				{
					if (isFirstPart)
					{
						yield return ActualNewLine;
						yield return $"    where {genericParameter.Name} : ";
					}
					else
					{
						yield return ", ";
					}

					yield return RenderTypeName(genericConstraint.GetTypeInfo(), seeAlsoMembers);
					isFirstPart = false;
				}

				if (!isStruct && genericParameter.GetTypeInfo().GenericParameterAttributes.HasFlag(GenericParameterAttributes.DefaultConstructorConstraint))
				{
					if (isFirstPart)
					{
						yield return ActualNewLine;
						yield return $"    where {genericParameter.Name} : ";
					}
					else
					{
						yield return ", ";
					}

					yield return "new()";
				}
			}

			if (typeKind == TypeKind.Delegate || memberInfo is EventInfo || memberInfo is FieldInfo)
				yield return ";";
		}

		private static Type GetValueType(MemberInfo member)
		{
			var eventInfo = member as EventInfo;
			if (eventInfo != null)
				return eventInfo.EventHandlerType;

			var propertyInfo = member as PropertyInfo;
			if (propertyInfo != null)
				return propertyInfo.PropertyType;

			var fieldInfo = member as FieldInfo;
			if (fieldInfo != null)
				return fieldInfo.FieldType;

			var methodInfo = member as MethodInfo ?? TryGetDelegateInvoke(member);
			if (methodInfo != null)
				return methodInfo.ReturnType;

			return null;
		}

		private static bool ParameterHasDefaultValue(ParameterInfo parameterInfo)
		{
			if (parameterInfo.Attributes.HasFlag(ParameterAttributes.HasDefault))
				return true;

			if (parameterInfo.ParameterType == typeof(decimal) || parameterInfo.ParameterType == typeof(decimal?))
				return parameterInfo.HasDefaultValue;

			return false;
		}

		private static bool CanRenderParameterConstant(ParameterInfo parameterInfo)
		{
			return TryGetBuiltInTypeName(parameterInfo.ParameterType) != null ||
				TryGetBuiltInTypeName(Nullable.GetUnderlyingType(parameterInfo.ParameterType)) != null ||
				parameterInfo.ParameterType.GetTypeInfo().IsEnum;
		}

		private static string RenderConstant(object value)
		{
			if (value == null)
				return "null";

			if (value is bool valueAsBool)
				return valueAsBool ? "true" : "false";

			if (value is char valueAsChar)
				return RenderChar(valueAsChar);

			if (value is string valueAsString)
				return RenderString(valueAsString);

			Type type = value.GetType();
			if (type.GetTypeInfo().IsEnum)
			{
				return string.Join(" | ", value.ToString()
					.Split(new[] { ", " }, StringSplitOptions.None)
					.Select(x => $"{type.Name}.{x}"));
			}

			string rendered = Convert.ToString(value, CultureInfo.InvariantCulture);

			if (value is double)
				rendered += "m";

			return rendered;
		}

		private static string RenderString(string value)
		{
			var builder = new StringBuilder("\"");
			foreach (char ch in value)
				builder.Append(ch == '\'' ? "'" : EscapeChar(ch));
			return builder.Append('"').ToString();
		}

		private static string RenderChar(char ch) => "'" + (ch == '\"' ? "\"" : EscapeChar(ch)) + "'";

		private static string EscapeChar(char ch)
		{
			switch (ch)
			{
			case '\'':
				return @"\'";
			case '\"':
				return @"\""";
			case '\\':
				return @"\\";
			case '\a':
				return @"\a";
			case '\b':
				return @"\b";
			case '\f':
				return @"\f";
			case '\n':
				return @"\n";
			case '\r':
				return @"\r";
			case '\t':
				return @"\t";
			case '\v':
				return @"\v";
			default:
				return char.IsControl(ch) ? $"\\u{((int) ch):x4}" : ch.ToString();
			}
		}

		private static string RenderGenericParameters(Type[] genericParameters)
		{
			var stringBuilder = new StringBuilder();
			for (int index = 0; index < genericParameters.Length; index++)
			{
				var genericParameter = genericParameters[index];
				stringBuilder.Append((index == 0 ? "<" : "") +
					(genericParameter.GetTypeInfo().GenericParameterAttributes.HasFlag(GenericParameterAttributes.Covariant) ? "out " : "") +
					(genericParameter.GetTypeInfo().GenericParameterAttributes.HasFlag(GenericParameterAttributes.Contravariant) ? "in " : "") +
					genericParameter.Name +
					(index < genericParameters.Length - 1 ? ", " : "") +
					(index == genericParameters.Length - 1 ? ">" : ""));
			}
			return stringBuilder.ToString();
		}

		private static string RenderShortGenericParameters(Type[] genericParameters)
		{
			if (genericParameters == null)
				return "";

			var stringBuilder = new StringBuilder();
			for (int index = 0; index < genericParameters.Length; index++)
			{
				var genericParameter = genericParameters[index];
				stringBuilder.Append((index == 0 ? "<" : "") +
					genericParameter.Name +
					(index < genericParameters.Length - 1 ? "," : "") +
					(index == genericParameters.Length - 1 ? ">" : ""));
			}
			return stringBuilder.ToString();
		}

		private static string RenderTypeName(TypeInfo typeInfo, ICollection<MemberInfo> seeAlso = null)
		{
			if (typeInfo.IsArray)
				return $"{RenderTypeName(typeInfo.GetElementType().GetTypeInfo(), seeAlso)}[]";

			if (typeInfo.IsByRef)
				return RenderTypeName(typeInfo.GetElementType().GetTypeInfo(), seeAlso);

			var nullableOfType = Nullable.GetUnderlyingType(typeInfo.AsType());
			if (nullableOfType != null)
				return $"{RenderTypeName(nullableOfType.GetTypeInfo(), seeAlso)}?";

			string builtIn = TryGetBuiltInTypeName(typeInfo.AsType());
			if (builtIn != null)
				return builtIn;

			seeAlso?.Add(typeInfo);

			return GetShortName(typeInfo) + RenderGenericArguments(typeInfo.GenericTypeArguments, seeAlso);
		}

		private static string RenderGenericArguments(Type[] genericArguments, ICollection<MemberInfo> seeAlso = null)
		{
			if (genericArguments == null)
				return "";

			var stringBuilder = new StringBuilder();
			for (int index = 0; index < genericArguments.Length; index++)
			{
				var genericArgument = genericArguments[index];
				stringBuilder.Append((index == 0 ? "<" : "") +
					RenderTypeName(genericArgument.GetTypeInfo(), seeAlso) +
					(index < genericArguments.Length - 1 ? ", " : "") +
					(index == genericArguments.Length - 1 ? ">" : ""));
			}
			return stringBuilder.ToString();
		}

		private static string TryGetBuiltInTypeName(Type type)
		{
			if (type == typeof(void))
				return "void";
			else if (type == typeof(bool))
				return "bool";
			else if (type == typeof(byte))
				return "byte";
			else if (type == typeof(sbyte))
				return "sbyte";
			else if (type == typeof(char))
				return "char";
			else if (type == typeof(decimal))
				return "decimal";
			else if (type == typeof(double))
				return "double";
			else if (type == typeof(float))
				return "float";
			else if (type == typeof(int))
				return "int";
			else if (type == typeof(uint))
				return "uint";
			else if (type == typeof(long))
				return "long";
			else if (type == typeof(ulong))
				return "ulong";
			else if (type == typeof(object))
				return "object";
			else if (type == typeof(short))
				return "short";
			else if (type == typeof(ushort))
				return "ushort";
			else if (type == typeof(string))
				return "string";
			else
				return null;
		}

		private static bool IsStatic(MemberInfo memberInfo)
		{
			var typeInfo = memberInfo as TypeInfo;
			if (typeInfo != null)
				return typeInfo.IsClass && typeInfo.IsAbstract && typeInfo.IsSealed;

			var eventInfo = memberInfo as EventInfo;
			if (eventInfo != null)
				return eventInfo.AddMethod.IsStatic;

			var propertyInfo = memberInfo as PropertyInfo;
			if (propertyInfo != null)
				return (propertyInfo.GetMethod ?? propertyInfo.SetMethod)?.IsStatic ?? false;

			var fieldInfo = memberInfo as FieldInfo;
			if (fieldInfo != null)
				return fieldInfo.IsStatic && !fieldInfo.IsLiteral;

			var methodBase = memberInfo as MethodBase;
			if (methodBase != null)
				return methodBase.IsStatic;

			return false;
		}

		private static bool IsAbstract(MemberInfo memberInfo)
		{
			var typeInfo = memberInfo as TypeInfo;
			if (typeInfo != null && !typeInfo.IsInterface)
				return typeInfo.IsAbstract;

			if (memberInfo.DeclaringType?.GetTypeInfo().IsInterface == true)
				return false;

			var eventInfo = memberInfo as EventInfo;
			if (eventInfo != null)
				return eventInfo.AddMethod != null && IsAbstract(eventInfo.AddMethod);

			var propertyInfo = memberInfo as PropertyInfo;
			if (propertyInfo != null)
			{
				return (propertyInfo.GetMethod != null && IsAbstract(propertyInfo.GetMethod)) ||
					(propertyInfo.SetMethod != null && IsAbstract(propertyInfo.SetMethod));
			}

			var methodBase = memberInfo as MethodBase;
			if (methodBase != null)
				return methodBase.IsAbstract;

			return false;
		}

		private static bool IsVirtual(MemberInfo memberInfo)
		{
			if (memberInfo.DeclaringType?.GetTypeInfo().IsInterface == true)
				return false;

			var eventInfo = memberInfo as EventInfo;
			if (eventInfo != null)
				return eventInfo.AddMethod != null && IsVirtual(eventInfo.AddMethod);

			var propertyInfo = memberInfo as PropertyInfo;
			if (propertyInfo != null)
			{
				return (propertyInfo.GetMethod != null && IsVirtual(propertyInfo.GetMethod)) ||
					(propertyInfo.SetMethod != null && IsVirtual(propertyInfo.SetMethod));
			}

			var methodInfo = memberInfo as MethodInfo;
			if (methodInfo != null)
				return methodInfo.IsVirtual && !methodInfo.IsFinal && methodInfo.GetRuntimeBaseDefinition().DeclaringType == methodInfo.DeclaringType;

			return false;
		}

		private static bool IsOverride(MemberInfo memberInfo)
		{
			if (memberInfo.DeclaringType?.GetTypeInfo().IsInterface == true)
				return false;

			var eventInfo = memberInfo as EventInfo;
			if (eventInfo != null)
				return eventInfo.AddMethod != null && IsOverride(eventInfo.AddMethod);

			var propertyInfo = memberInfo as PropertyInfo;
			if (propertyInfo != null)
			{
				return (propertyInfo.GetMethod != null && IsOverride(propertyInfo.GetMethod)) ||
					(propertyInfo.SetMethod != null && IsOverride(propertyInfo.SetMethod));
			}

			var methodInfo = memberInfo as MethodInfo;
			if (methodInfo != null)
				return methodInfo.IsVirtual && !methodInfo.IsFinal && methodInfo.GetRuntimeBaseDefinition().DeclaringType != methodInfo.DeclaringType;

			return false;
		}

		private static bool IsConst(MemberInfo memberInfo)
		{
			return (memberInfo as FieldInfo)?.IsLiteral ?? false;
		}

		private static bool IsReadOnly(MemberInfo memberInfo)
		{
			return (memberInfo as FieldInfo)?.IsInitOnly ?? false;
		}

		private static bool IsFlagsEnum(MemberInfo memberInfo)
		{
			var type = memberInfo as TypeInfo;
			return type != null && type.IsEnum && type.GetCustomAttributes<FlagsAttribute>().Any();
		}

		private static XmlDocVisibilityLevel GetVisibility(MemberInfo memberInfo)
		{
			return GetVisibility(memberInfo, XmlDocVisibilityLevel.Protected);
		}

		private static XmlDocVisibilityLevel GetVisibility(MemberInfo memberInfo, XmlDocVisibilityLevel protectedInternal)
		{
			var typeInfo = memberInfo as TypeInfo;
			if (typeInfo != null)
			{
				var visibility = GetTypeVisibility(typeInfo);
				return typeInfo.IsNested ? GetMostPrivate(visibility, GetTypeVisibility(typeInfo.DeclaringType.GetTypeInfo(), protectedInternal)) : visibility;
			}

			var eventInfo = memberInfo as EventInfo;
			if (eventInfo != null)
				return GetMethodVisibility(eventInfo.AddMethod, protectedInternal);

			var propertyInfo = memberInfo as PropertyInfo;
			if (propertyInfo != null)
				return GetPropertyVisibility(propertyInfo, protectedInternal);

			var fieldInfo = memberInfo as FieldInfo;
			if (fieldInfo != null)
				return GetFieldVisibility(fieldInfo, protectedInternal);

			var methodBase = memberInfo as MethodBase;
			if (methodBase != null)
				return GetMethodVisibility(methodBase, protectedInternal);

			return XmlDocVisibilityLevel.Private;
		}

		private static XmlDocVisibilityLevel GetTypeVisibility(TypeInfo typeInfo, XmlDocVisibilityLevel protectedInternal = XmlDocVisibilityLevel.Protected)
		{
			if (typeInfo.IsPublic || typeInfo.IsNestedPublic)
				return XmlDocVisibilityLevel.Public;
			else if (typeInfo.IsNestedFamORAssem)
				return protectedInternal;
			else if (typeInfo.IsNestedFamily)
				return XmlDocVisibilityLevel.Protected;
			else if (typeInfo.IsNestedAssembly || typeInfo.IsNestedFamANDAssem)
				return XmlDocVisibilityLevel.Internal;
			else
				return XmlDocVisibilityLevel.Private;
		}

		private static XmlDocVisibilityLevel GetMethodVisibility(MethodBase methodBase, XmlDocVisibilityLevel protectedInternal = XmlDocVisibilityLevel.Protected)
		{
			if (methodBase.IsPublic)
				return XmlDocVisibilityLevel.Public;
			else if (methodBase.IsFamilyOrAssembly)
				return protectedInternal;
			else if (methodBase.IsFamily)
				return XmlDocVisibilityLevel.Protected;
			else if (methodBase.IsAssembly || methodBase.IsFamilyAndAssembly)
				return XmlDocVisibilityLevel.Internal;
			else
				return XmlDocVisibilityLevel.Private;
		}

		private static XmlDocVisibilityLevel GetPropertyVisibility(PropertyInfo propertyInfo, XmlDocVisibilityLevel protectedInternal = XmlDocVisibilityLevel.Protected)
		{
			var getMethod = propertyInfo.GetMethod;
			var setMethod = propertyInfo.SetMethod;
			if (getMethod == null && setMethod == null)
				throw new InvalidOperationException();

			if (getMethod != null && setMethod == null)
				return GetMethodVisibility(getMethod);
			if (getMethod == null)
				return GetMethodVisibility(setMethod);

			return GetMostPublic(
				GetMethodVisibility(propertyInfo.GetMethod, protectedInternal),
				GetMethodVisibility(propertyInfo.SetMethod, protectedInternal));
		}

		private static XmlDocVisibilityLevel GetFieldVisibility(FieldInfo fieldInfo, XmlDocVisibilityLevel protectedInternal = XmlDocVisibilityLevel.Protected)
		{
			if (fieldInfo.IsPublic)
				return XmlDocVisibilityLevel.Public;
			else if (fieldInfo.IsFamilyOrAssembly)
				return protectedInternal;
			else if (fieldInfo.IsFamily)
				return XmlDocVisibilityLevel.Protected;
			else if (fieldInfo.IsAssembly || fieldInfo.IsFamilyAndAssembly)
				return XmlDocVisibilityLevel.Internal;
			else
				return XmlDocVisibilityLevel.Private;
		}

		private static string GetAccessModifier(MemberInfo memberInfo)
		{
			var visibility = GetVisibility(memberInfo, XmlDocVisibilityLevel.ProtectedInternal);
			switch (visibility)
			{
			case XmlDocVisibilityLevel.Public:
				return "public";
			case XmlDocVisibilityLevel.ProtectedInternal:
				return "protected internal";
			case XmlDocVisibilityLevel.Protected:
				return "protected";
			case XmlDocVisibilityLevel.Internal:
				return "internal";
			case XmlDocVisibilityLevel.Private:
				return "private";
			default:
				throw new InvalidOperationException();
			}
		}

		private enum TypeKind
		{
			Unknown,
			Class,
			Interface,
			Struct,
			Enum,
			Delegate,
		}

		private static TypeKind GetTypeKind(TypeInfo typeInfo)
		{
			if (typeof(Delegate).GetTypeInfo().IsAssignableFrom(typeInfo))
				return TypeKind.Delegate;
			else if (typeInfo.IsClass)
				return TypeKind.Class;
			else if (typeInfo.IsInterface)
				return TypeKind.Interface;
			else if (typeInfo.IsEnum)
				return TypeKind.Enum;
			else if (typeInfo.IsValueType)
				return TypeKind.Struct;
			else
				return TypeKind.Unknown;
		}

		private enum MemberOrder
		{
			Constructor,
			LifetimeProperty,
			LifetimeField,
			LifetimeMethod,
			InstanceProperty,
			InstanceField,
			InstanceEvent,
			InstanceMethod,
			StaticProperty,
			StaticField,
			StaticEvent,
			StaticMethod,
			Operator,
			Type,
			Unknown,
		}

		private static MemberOrder GetMemberOrder(MemberInfo memberInfo)
		{
			if (memberInfo is TypeInfo)
				return MemberOrder.Type;
			else if (memberInfo is ConstructorInfo)
				return MemberOrder.Constructor;
			else if (memberInfo is PropertyInfo)
				return GetPropertyOrder((PropertyInfo) memberInfo);
			else if (memberInfo is EventInfo)
				return GetEventOrder((EventInfo) memberInfo);
			else if (memberInfo is MethodInfo)
				return GetMethodOrder((MethodInfo) memberInfo);
			else if (memberInfo is FieldInfo)
				return GetFieldOrder((FieldInfo) memberInfo);
			else
				return MemberOrder.Unknown;
		}

		private static MemberOrder GetPropertyOrder(PropertyInfo propertyInfo)
		{
			var method = propertyInfo.GetMethod ?? propertyInfo.SetMethod;
			if (!method.IsStatic)
				return MemberOrder.InstanceProperty;
			else if (propertyInfo.PropertyType == propertyInfo.DeclaringType)
				return MemberOrder.LifetimeProperty;
			else
				return MemberOrder.StaticProperty;
		}

		private static MemberOrder GetEventOrder(EventInfo eventInfo)
		{
			var method = eventInfo.AddMethod ?? eventInfo.RemoveMethod;
			if (!method.IsStatic)
				return MemberOrder.InstanceEvent;
			else
				return MemberOrder.StaticEvent;
		}

		private static MemberOrder GetMethodOrder(MethodInfo methodInfo)
		{
			if (methodInfo.Name.StartsWith("op_", StringComparison.Ordinal))
				return MemberOrder.Operator;
			else if (!methodInfo.IsStatic)
				return MemberOrder.InstanceMethod;
			else if (methodInfo.ReturnType == methodInfo.DeclaringType)
				return MemberOrder.LifetimeMethod;
			else
				return MemberOrder.StaticMethod;
		}

		private static MemberOrder GetFieldOrder(FieldInfo fieldInfo)
		{
			if (!fieldInfo.IsStatic)
				return MemberOrder.InstanceField;
			else if (fieldInfo.FieldType == fieldInfo.DeclaringType)
				return MemberOrder.LifetimeField;
			else
				return MemberOrder.StaticField;
		}

		private static IEnumerable<T> OrderMembers<T>(IEnumerable<T> items, Func<T, MemberInfo> getMemberInfo)
		{
			return items.OrderBy(x => (int) GetMemberOrder(getMemberInfo(x)))
				.ThenBy(x => GetShortName(getMemberInfo(x)).ToString(), StringComparer.OrdinalIgnoreCase)
				.ThenBy(x => GetGenericArguments(getMemberInfo(x)).Length)
				.ThenBy(x => GetParameters(getMemberInfo(x)).Length)
				.ThenBy(x => GetParameterShortNames(getMemberInfo(x)), StringComparer.OrdinalIgnoreCase);
		}

		private static MethodInfo TryGetDelegateInvoke(MemberInfo memberInfo)
		{
			var typeInfo = memberInfo as TypeInfo;
			return typeInfo != null && typeof(Delegate).GetTypeInfo().IsAssignableFrom(typeInfo) ? typeInfo.DeclaredMethods.FirstOrDefault(x => x.Name == "Invoke") : null;
		}

		private static Type[] GetGenericArguments(MemberInfo memberInfo)
		{
			var type = memberInfo as TypeInfo;
			if (type != null)
				return type.GenericTypeParameters;

			var method = memberInfo as MethodInfo;
			return method?.GetGenericArguments() ?? new Type[0];
		}

		private static ParameterInfo[] GetParameters(MemberInfo memberInfo)
		{
			var delegateInvoke = TryGetDelegateInvoke(memberInfo);
			if (delegateInvoke != null)
				return GetParameters(delegateInvoke);

			var propertyInfo = memberInfo as PropertyInfo;
			if (propertyInfo != null)
				return propertyInfo.GetIndexParameters();

			var method = memberInfo as MethodBase;
			return method?.GetParameters() ?? new ParameterInfo[0];
		}

		private static string GetParameterShortNames(MemberInfo memberInfo)
		{
			return string.Join(", ", GetParameters(memberInfo).Select(x => RenderTypeName(x.ParameterType.GetTypeInfo())));
		}

		private static bool IsLessDerived(TypeInfo a, TypeInfo b)
		{
			if (!a.IsAssignableFrom(b))
				return false;
			if (a.IsGenericType && b.IsGenericType && a.GetGenericTypeDefinition().GetTypeInfo() == b.GetGenericTypeDefinition().GetTypeInfo())
			{
				var parameters = a.GetGenericTypeDefinition().GetTypeInfo().GenericTypeParameters;
				for (int i = 0; i < parameters.Length; i++)
				{
					var paramAttributes = parameters[i].GetTypeInfo().GenericParameterAttributes;
					var aArgInfo = a.GenericTypeArguments[i].GetTypeInfo();
					var bArgInfo = b.GenericTypeArguments[i].GetTypeInfo();
					if (paramAttributes.HasFlag(GenericParameterAttributes.Contravariant) && !aArgInfo.IsAssignableFrom(bArgInfo))
						return false;
					if (paramAttributes.HasFlag(GenericParameterAttributes.Covariant) && aArgInfo.IsAssignableFrom(bArgInfo))
						return false;
				}
			}
			return true;
		}

		private static bool IsKeyword(string value) => s_keywords.Contains(value);

		private string ToMarkdown(XmlDocInline inline, MarkdownContext context)
		{
			string text = inline.Text ?? "";

			MemberInfo seeMemberInfo = null;
			if (inline.SeeRef != null)
				context.MembersByXmlDocName.TryGetValue(inline.SeeRef, out seeMemberInfo);

			if (text.Length == 0)
			{
				if (seeMemberInfo != null)
					text = GetOperatorKeywordName(GetShortName(seeMemberInfo));
				else if (inline.SeeRef != null)
					text = XmlDocUtility.GetShortNameForXmlDocRef(inline.SeeRef);
				else if (inline.LinkUrl != null)
					text = inline.LinkUrl;
				else if (inline.LangWord != null)
					text = SurroundCode(inline.LangWord);
			}

			if (text.Length != 0)
			{
				bool isCode = inline.IsCode || seeMemberInfo != null;
				if (isCode)
					text = SurroundCode(text);

				if (inline.IsParamRef || inline.IsTypeParamRef)
					text = $"*{text}*";

				text = WrapMarkdownRefLink(text, seeMemberInfo, context, isCode: inline.IsCode, linkUrl: inline.LinkUrl);
			}

			text = Regex.Replace(text, @"\s+", " ");

			return text;
		}

		private string WrapMarkdownRefLink(string text, MemberInfo memberInfo, MarkdownContext context, bool isCode = false, string linkUrl = null)
		{
			string extension = GetFileExtension();
			string xmlDocRef = memberInfo == null ? null : XmlDocUtility.GetXmlDocRef(memberInfo);
			bool isLocal = xmlDocRef != null && context.MembersByXmlDocName.ContainsKey(xmlDocRef);
			var externalDoc = isLocal || xmlDocRef == null ? null : FindExternalDocumentation(memberInfo);
			if (memberInfo != null && xmlDocRef != XmlDocUtility.GetXmlDocRef(context.MemberInfo) && (isLocal || externalDoc != null))
			{
				string path;

				var typeInfo = memberInfo as TypeInfo;
				if (context.MemberInfo != null)
				{
					if (typeInfo != null)
					{
						path = $"{GetNamespaceUriName(typeInfo.Namespace)}/{GetSafeTypeUriName(typeInfo)}{extension}";
					}
					else
					{
						path = $"{GetNamespaceUriName(memberInfo.DeclaringType?.Namespace)}/{GetTypeUriName(memberInfo.DeclaringType.GetTypeInfo())}/{GetMemberUriName(memberInfo)}{extension}";
					}
				}
				else if (context.TypeInfo != null)
				{
					if (typeInfo != null)
					{
						path = $"{GetNamespaceUriName(typeInfo.Namespace)}/{GetSafeTypeUriName(typeInfo)}{extension}";
					}
					else
					{
						path = $"{GetNamespaceUriName(memberInfo.DeclaringType?.Namespace)}/{GetTypeUriName(memberInfo.DeclaringType.GetTypeInfo())}/{GetMemberUriName(memberInfo)}{extension}";
					}
				}
				else
				{
					if (typeInfo != null)
						path = $"{GetNamespaceUriName(typeInfo.Namespace)}/{GetSafeTypeUriName(typeInfo)}{extension}";
					else
						path = $"{GetNamespaceUriName(memberInfo.DeclaringType?.Namespace)}/{GetTypeUriName(memberInfo.DeclaringType.GetTypeInfo())}/{GetMemberUriName(memberInfo)}{extension}";
				}

				if (!string.IsNullOrEmpty(context.PageLocation))
				{
					path = MakeRelative(context.PageLocation, path);
				}

				text = $"[{text}]({path})";
			}
			else if (linkUrl != null)
			{
				text = $"[{text}]({linkUrl})";
			}

			return isCode ? text : EscapeHtml(text);
		}

		private string MakeRelative(string baseUri, string path)
		{
			Uri a = new Uri("file:///" + baseUri);
			Uri b = new Uri("file:///" + path);
			Uri rel = a.MakeRelativeUri(b);
			string result = rel.ToString();
			if (string.IsNullOrEmpty(result))
			{
				// then the file name is the link
				return b.Segments.Last();
			}
			return result;
		}

		private string ToMarkdown(IEnumerable<XmlDocInline> inlines, MarkdownContext context)
			=> inlines == null ? null : string.Concat(inlines.Select(x => ToMarkdown(x, context))).Trim();

		private IEnumerable<string> ToMarkdown(IReadOnlyList<XmlDocBlock> blocks, MarkdownContext context)
		{
			for (int index = 0; index < blocks.Count; index++)
			{
				if (index != 0)
					yield return "";

				var block = blocks[index];

				if (block.ListKind == XmlDocListKind.Bullet || block.ListKind == XmlDocListKind.Number)
				{
					int number = 0;
					while (true)
					{
						string prefix = new string(' ', block.ListDepth * 2) + (block.ListKind == XmlDocListKind.Number ? $"{++number}. " : "* ");
						string markdown = ToMarkdown(block.Inlines, context);

						if (block.IsListTerm)
						{
							markdown = $"**{markdown}**";

							var afterTermBlock = index + 1 < blocks.Count ? blocks[index + 1] : null;
							if (afterTermBlock != null && afterTermBlock.ListKind == block.ListKind && afterTermBlock.ListDepth == block.ListDepth && !afterTermBlock.IsListTerm)
							{
								markdown += " – " + ToMarkdown(afterTermBlock.Inlines, context);
								index++;
							}
						}

						yield return prefix + markdown;

						var nextBlock = index + 1 < blocks.Count ? blocks[index + 1] : null;
						if (nextBlock == null || nextBlock.ListKind != block.ListKind)
							break;

						block = nextBlock;
						index++;
					}
				}
				else
				{
					if (block.IsCode)
					{
						yield return "```csharp";
						foreach (var inline in block.Inlines)
							yield return inline.Text.Replace(Environment.NewLine, ActualNewLine);
						yield return "```";
					}
					else
					{
						string markdown = ToMarkdown(block.Inlines, context);
						if (block.IsListHeader || block.IsListTerm)
							markdown = $"**{markdown}**";
						yield return markdown;
					}
				}
			}
		}

		private class MarkdownContext
		{
			public MarkdownContext(XmlDocAssembly xmlDocAssembly, IReadOnlyDictionary<string, MemberInfo> membersByXmlDocName,
				string assemblyFileName, string sourceCodePath, XmlDocSourceCodeStyle sourceCodeStyle, string rootNamespace,
				string pageLocation, string assemblyLocation)
			{
				XmlDocAssembly = xmlDocAssembly;
				MembersByXmlDocName = membersByXmlDocName;
				AssemblyFileName = assemblyFileName;
				SourceCodePath = sourceCodePath;
				SourceCodeStyle = sourceCodeStyle;
				RootNamespace = rootNamespace;
				PageLocation = pageLocation;

				MetadataContext =
				  (!string.IsNullOrEmpty(sourceCodePath) && !string.IsNullOrEmpty(rootNamespace)) ?
				  new MetadataContext(assemblyLocation) : new MetadataContext();
			}

			public MarkdownContext(MarkdownContext context, MemberInfo memberInfo, string pageLocation)
			{
				XmlDocAssembly = context.XmlDocAssembly;
				MembersByXmlDocName = context.MembersByXmlDocName;
				AssemblyFileName = context.AssemblyFileName;
				SourceCodePath = context.SourceCodePath;
				SourceCodeStyle = context.SourceCodeStyle;
				RootNamespace = context.RootNamespace;
				PageLocation = pageLocation;
				MetadataContext = context.MetadataContext;

				var typeInfo = memberInfo as TypeInfo;
				if (typeInfo != null)
				{
					TypeInfo = typeInfo;
				}
				else if (memberInfo != null)
				{
					TypeInfo = memberInfo.DeclaringType.GetTypeInfo();
					MemberInfo = memberInfo;
				}
			}

			public TypeInfo TypeInfo { get; }

			public MemberInfo MemberInfo { get; }

			public XmlDocAssembly XmlDocAssembly { get; }

			public IReadOnlyDictionary<string, MemberInfo> MembersByXmlDocName { get; }

			public string AssemblyFileName { get; }

			public string SourceCodePath { get; }

			public XmlDocSourceCodeStyle SourceCodeStyle { get; }

			public string RootNamespace { get; }

			public string PageLocation { get; }

			public MetadataContext MetadataContext { get; }
		}

		private class MetadataContext
		{
			private Dictionary<string, List<string>> typemap =
				new Dictionary<string, List<string>>();

			private Dictionary<string, string> sourcelink =
				new Dictionary<string, string>();

			public MetadataContext()
			{
				PrefixLength = 0;
				PdbLoaded = false;
			}

			public MetadataContext(string assemblyPath)
			{
				var index = 0;
				using (var stream = File.OpenRead(assemblyPath))
				using (var reader = new PEReader(stream))
				{
					Func<string, Stream> streamProvider = p => new FileStream(p, FileMode.Open, FileAccess.Read);

					var metadata = reader.GetMetadataReader(MetadataReaderOptions.Default);
					PdbLoaded = reader.TryOpenAssociatedPortablePdb(stream.Name, streamProvider, out var metadataReaderProvider,
						out var pdbPath);

					if (PdbLoaded)
					{
						var metadataSymbol = metadataReaderProvider.GetMetadataReader();

						// Load all the file paths
						var names = metadataSymbol.Documents
						   .Select(metadataSymbol.GetDocument)
						   .Select(d => metadataSymbol.GetString(d.Name))
						   .Distinct()
						   .ToList();

						// identify the common prefix
						var shortest = names.OrderBy(s => s.Length).First();
						for (; index < shortest.Length; ++index)
						{
							var c = shortest[index];
							var match = names.All(n => n[index] == c);
							if (!match)
								break;
						}

						// for each type, identify the file(s) it refers to
						var types = metadata.TypeDefinitions.Select(metadata.GetTypeDefinition);

						typemap = types.ToDictionary(t => TypeName(metadata, t),
						   t => t.GetMethods().Select(m => metadataSymbol.GetMethodDebugInformation(m))
								.SelectMany(a => a.GetSequencePoints())
								.Select(a => metadataSymbol.GetDocument(a.Document))
								.Select(d => metadataSymbol.GetString(d.Name))
								.Distinct()
								.ToList()
						   );

						// identify sourcelink data, if present
						var custom = metadataSymbol.CustomDebugInformation
						  .Select(m => metadataSymbol.GetCustomDebugInformation(m))
						  .Where(c => metadataSymbol.GetGuid(c.Kind) ==
							 // magic ID -- https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#source-link-c-and-vb-compilers
							 // It works for F# too, haven't tried C++/CLI
							 Guid.Parse("cc110556-a091-4d38-9fec-25ab9a351a6a"))
						  .Select(c => metadataSymbol.GetBlobBytes(c.Value))
						  .FirstOrDefault();

						if (custom != null)
						{
							// Expect the blob to be well-formed
							using (var blob = new MemoryStream(custom))
							{
								var json = JsonDocument.Parse(blob);
								var root = json.RootElement;
								var documents = root.GetProperty("documents");
								using (var scan = documents.EnumerateObject())
								{
									foreach (var item in scan)
									{
										sourcelink.Add(
											item.Name,
											item.Value.GetString()
											);
									}
								}
							}
						}
					}
				}

				PrefixLength = index;
			}

			public int PrefixLength { get; }

			public bool PdbLoaded { get; }

			public IEnumerable<string> this[string typename] =>
				typemap.TryGetValue(typename, out var documents) ?
						new ReadOnlyCollection<string>(documents) :
						Enumerable.Empty<string>();

			public bool TrySourceLink(string filepath, out string link)
			{
				if (sourcelink.TryGetValue(filepath, out link))
				{
					return true;
				}

				return TryLocateMatch(filepath, sourcelink, out link);
			}

			private static bool TryLocateMatch(string file,
				Dictionary<string, string> dict, out string match)
			{
				if (TryFindClosestMatch(file, dict, out var best, out var relative))
				{
					var replacement =
					  Path.Combine(relative, Path.GetFileName(file)).Replace('\\', '/');
					var url = dict[best].Replace("*", replacement);
					dict.Add(file, url);
					match = url;
					return true;
				}
				match = file;
				return false;
			}

			private static bool TryFindClosestMatch(string file,
				Dictionary<string, string> dict, out string best,
				out string relative)
			{
				var unmapped = dict.Keys.Where(k => Path.GetFileName(k) == "*");
				var dir = Path.GetDirectoryName(file);

				var candidate =
					unmapped.Select(x => new
					{
						Best = x,
						Relative = GetRelativePath(Path.GetDirectoryName(x), dir)
					})
						.Where(m => m.Relative.IndexOf("..", StringComparison.Ordinal) < 0)
						.OrderBy(m => m.Relative.Length)
						.FirstOrDefault();

				best = candidate?.Best;
				relative = candidate?.Relative;
				return candidate != null;
			}

			private static string EnsureEndsWith(string s, string c)
			{
				return s.EndsWith(c, StringComparison.Ordinal) ?
					s : s + c;
			}

			private static string GetRelativePath(string relativeTo, string path)
			{
				if (Path.GetFullPath(path) == Path.GetFullPath(relativeTo))
				{
					return String.Empty;
				}

				Func<string, string> ender = s => EnsureEndsWith(s, Path.DirectorySeparatorChar.ToString());

				var uri = new Uri(ender(relativeTo));

				return Uri.UnescapeDataString(uri.MakeRelativeUri(new Uri(path)).ToString())
				   .Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
			}

			private static string TypeName(MetadataReader metadata, TypeDefinition t)
			{
				var name = metadata.GetString(t.Name);
				if (t.IsNested)
					return TypeName(metadata, metadata.GetTypeDefinition(t.GetDeclaringType())) +
					  "+" + name;

				return metadata.GetString(t.Namespace) + "." + metadata.GetString(t.Name);
			}
		}

		static readonly HashSet<string> s_keywords = new HashSet<string>
		{
			"abstract",
			"as",
			"base",
			"bool",
			"break",
			"byte",
			"case",
			"catch",
			"char",
			"checked",
			"class",
			"const",
			"continue",
			"decimal",
			"default",
			"delegate",
			"do",
			"double",
			"else",
			"enum",
			"event",
			"explicit",
			"extern",
			"false",
			"finally",
			"fixed",
			"float",
			"for",
			"foreach",
			"goto",
			"if",
			"implicit",
			"in",
			"int",
			"interface",
			"internal",
			"is",
			"lock",
			"long",
			"namespace",
			"new",
			"null",
			"object",
			"operator",
			"out",
			"override",
			"params",
			"private",
			"protected",
			"public",
			"readonly",
			"ref",
			"return",
			"sbyte",
			"sealed",
			"short",
			"sizeof",
			"stackalloc",
			"static",
			"string",
			"struct",
			"switch",
			"this",
			"throw",
			"true",
			"try",
			"typeof",
			"uint",
			"ulong",
			"unchecked",
			"unsafe",
			"ushort",
			"using",
			"virtual",
			"void",
			"volatile",
			"while",
		};
		}
}
