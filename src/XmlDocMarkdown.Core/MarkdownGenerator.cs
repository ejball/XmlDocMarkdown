using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;

namespace XmlDocMarkdown.Core
{
	internal sealed class MarkdownGenerator
	{
		public string? NewLine { get; set; }

		public string? SourceCodePath { get; set; }

		public string? RootNamespace { get; set; }

		public string? RootPageLocation { get; set; }

		public bool IncludeObsolete { get; set; }

		public bool SkipUnbrowsable { get; set; }

		public bool SkipCompilerGenerated { get; set; }

		public bool NamespacePages { get; set; }

		public XmlDocVisibilityLevel Visibility { get; set; }

		public IReadOnlyList<ExternalDocumentation>? ExternalDocs { get; set; }

		public IReadOnlyList<NamedText> GenerateOutput(Assembly assembly, XmlDocAssembly xmlDocAssembly) =>
			DoGenerateOutput(assembly, xmlDocAssembly).ToList();

		public static string GetCodeGenComment(string assemblyName) => $"<!-- DO NOT EDIT: generated by xmldocmd for {assemblyName} -->";

		private string ActualNewLine => NewLine ?? Environment.NewLine;

		public string? FrontMatter { get; internal set; }

		public bool PermalinkPretty { get; internal set; }

		private IEnumerable<NamedText> DoGenerateOutput(Assembly assembly, XmlDocAssembly xmlDocAssembly)
		{
			var extension = GetFileExtension();
			var assemblyName = assembly.GetName().Name;
			var assemblyFilePath = assembly.Modules.FirstOrDefault()?.FullyQualifiedName;
			var assemblyFileName = assemblyFilePath != null ? Path.GetFileName(assemblyFilePath) : assemblyName;

			var visibleTypes = assembly
				.DefinedTypes
				.Where(IsVisible)
				.ToList();

			var membersByXmlDocName = visibleTypes
				.Where(x => new[] { TypeKind.Record, TypeKind.Class, TypeKind.Struct, TypeKind.Interface }.Contains(GetTypeKind(x)))
				.SelectMany(x => x.DeclaredMembers)
				.Where(x => !(x is TypeInfo) && IsVisible(x))
				.Concat(visibleTypes)
				.GroupBy(XmlDocUtility.GetXmlDocRef)
				.ToDictionary(x => x.Key!, x => x.Single());

			var visibleTypeRecords = visibleTypes
				.Select(typeInfo => new
				{
					TypeInfo = typeInfo,
					Path = GetTypeUriName(typeInfo) + ".md",
					ShortName = GetShortName(typeInfo),
					ShortSignature = GetShortSignature(typeInfo),
					Namespace = GetNamespaceName(typeInfo),
					Visibility = GetTypeVisibility(typeInfo),
				})
				.ToList();

			var visibleNamespaceRecords = visibleTypeRecords
				.Where(x => x.TypeInfo.DeclaringType == null)
				.GroupBy(x => x.Namespace)
				.Select(ng => new
				{
					Namespace = ng.Key,
					Types = ng
						.OrderBy(x => x.ShortName, StringComparer.OrdinalIgnoreCase)
						.ThenBy(x => x.Path, StringComparer.OrdinalIgnoreCase)
						.ToList(),
				})
				.OrderBy(x => x.Namespace, StringComparer.OrdinalIgnoreCase)
				.ToList();

			var sourceCodePath = SourceCodePath?.Trim('/');
			var rootPath = GetAssemblyUriName(assembly);
			var safeAssemblyName = GetSafeName(rootPath);
			var rootNamespace = RootNamespace ??
				visibleNamespaceRecords.OrderBy(x => x.Namespace.Length).ThenByDescending(x => x.Types.Count).Select(x => x.Namespace).FirstOrDefault(x => x.Length != 0);
			RootPageLocation = $"{safeAssemblyName}" + (PermalinkPretty ? "Assembly.md" : ".md");
			var context = new MarkdownContext(xmlDocAssembly, membersByXmlDocName, assemblyFileName, sourceCodePath, rootNamespace, RootPageLocation);
			yield return CreateNamedText(context.PageLocation, null, assemblyName, writer =>
			{
				var front = GetFrontMatter(assemblyName, $"{safeAssemblyName}" + (PermalinkPretty ? "Assembly" : "") + extension);
				if (!string.IsNullOrEmpty(front))
					writer.WriteLine(front!);

				writer.WriteLine($"# {assemblyName} assembly");

				foreach (var group in visibleNamespaceRecords)
				{
					writer.WriteLine();
					writer.WriteLine($"## {group.Namespace} namespace");

					foreach (var typeGroup in group.Types.GroupBy(x => x.Visibility))
					{
						writer.WriteLine();
						writer.WriteLine($"| {(typeGroup.Key == XmlDocVisibilityLevel.Public ? "public" : "internal")} type | description |");
						writer.WriteLine("| --- | --- |");
						foreach (var typeInfo in typeGroup)
						{
							var relative = GetPermalink(typeInfo.Path);
							var safeRelative = GetSafeName(relative);
							if (PermalinkPretty)
								safeRelative += "Type";
							var rel = MakeRelative(context.PageLocation, $"{GetNamespaceUriName(group.Namespace)}/{safeRelative}");
							var typeText = GetShortSignatureMarkdown(typeInfo.ShortSignature, rel);
							var summaryText = GetShortSummaryMarkdown(xmlDocAssembly, typeInfo.TypeInfo, context);
							writer.WriteLine($"| {typeText} | {summaryText} |");
						}
					}
				}

				writer.WriteLine();
				writer.WriteLine(GetCodeGenComment(assemblyFileName));
			});

			// create separate parent pages for each namespace in the assembly.
			foreach (var group in visibleNamespaceRecords)
			{
				var parentPageLocation = RootPageLocation;
				var parentContext = context;

				if (NamespacePages)
				{
					var namespacePath = group.Namespace;
					var safeNamespacePath = GetSafeName(namespacePath);
					parentPageLocation = $"{safeNamespacePath}Namespace.md";
					parentContext = new MarkdownContext(context, null, parentPageLocation);
					yield return CreateNamedText(parentPageLocation, context.PageLocation, group.Namespace, writer =>
					{
						var front = GetFrontMatter(namespacePath, $"{safeNamespacePath}Namespace");
						if (!string.IsNullOrEmpty(front))
							writer.WriteLine(front!);

						writer.WriteLine($"## {group.Namespace} namespace");

						foreach (var typeGroup in group.Types.GroupBy(x => x.Visibility))
						{
							writer.WriteLine();
							writer.WriteLine($"| {(typeGroup.Key == XmlDocVisibilityLevel.Public ? "public" : "internal")} type | description |");
							writer.WriteLine("| --- | --- |");
							foreach (var typeInfo in typeGroup)
							{
								var relative = GetPermalink(typeInfo.Path);
								var safeRelative = GetSafeName(relative);
								if (PermalinkPretty)
									safeRelative += "Type";
								var rel = MakeRelative(context.PageLocation, $"{GetNamespaceUriName(group.Namespace)}/{safeRelative}");
								var typeText = GetShortSignatureMarkdown(typeInfo.ShortSignature, rel);
								var summaryText = GetShortSummaryMarkdown(xmlDocAssembly, typeInfo.TypeInfo, context);
								writer.WriteLine($"| {typeText} | {summaryText} |");
							}
						}

						writer.WriteLine();
						writer.WriteLine(GetCodeGenComment(assemblyFileName));
					});
				}

				foreach (var visibleTypeRecord in visibleTypeRecords)
				{
					if (visibleTypeRecord.Namespace == group.Namespace)
					{
						var relative = GetPermalink(visibleTypeRecord.Path);
						var safeRelative = GetSafeName(relative);
						if (PermalinkPretty)
							safeRelative += "Type.md";
						var typePage = $"{GetNamespaceUriName(visibleTypeRecord.Namespace)}/{safeRelative}";
						yield return WriteMemberPage(
							path: typePage,
							title: GetFullMemberName(visibleTypeRecord.TypeInfo),
							parent: parentPageLocation,
							memberInfo: visibleTypeRecord.TypeInfo,
							context: parentContext);

						var typeKind = GetTypeKind(visibleTypeRecord.TypeInfo);
						if (typeKind is TypeKind.Record or TypeKind.Class or TypeKind.Struct or TypeKind.Interface)
						{
							var memberGroups = visibleTypeRecord.TypeInfo
								.DeclaredMembers
								.Where(x => !(x is TypeInfo) && IsVisible(x))
								.GroupBy(GetMemberUriName)
								.Select(tg => new
								{
									MemberUriName = tg.Key,
									Members = OrderMembers(tg, x => x).ToList(),
								})
								.ToList();

							foreach (var memberGroup in memberGroups)
							{
								yield return WriteMemberPage(
									path: $"{GetNamespaceUriName(visibleTypeRecord.Namespace)}/{GetTypeUriName(visibleTypeRecord.TypeInfo)}/{memberGroup.MemberUriName}.md",
									parent: typePage,
									title: memberGroup.MemberUriName,
									memberGroup: memberGroup.Members,
									context: context);
							}
						}
					}
				}
			}
		}

		private string? GetFrontMatter(string title, string relativeLink)
		{
			if (string.IsNullOrEmpty(FrontMatter))
				return null;

			var contents = File.ReadAllText(FrontMatter);
			return contents.Replace("$title", title).Replace("$ref", relativeLink);
		}

		private NamedText CreateNamedText(string name, string? parent, string title, Action<MarkdownWriter> writeTo)
		{
			using var stringWriter = new StringWriter();
			if (NewLine != null)
				stringWriter.NewLine = NewLine;

			var code = new MarkdownWriter(stringWriter);
			writeTo(code);
			return new NamedText(name, parent, title, stringWriter.ToString());
		}

		private static Collection<XmlDocBlock>? GetSummary(XmlDocAssembly xmlDocAssembly, MemberInfo member) =>
			GetSummary(xmlDocAssembly.FindMember(XmlDocUtility.GetXmlDocRef(member)), member);

		private static Collection<XmlDocBlock>? GetSummary(XmlDocMember? xmlDocMember, MemberInfo member)
		{
			var summary = xmlDocMember?.Summary;

			if (summary == null || summary.Count == 0)
			{
				var constructorInfo = member as ConstructorInfo;
				if (constructorInfo != null && !constructorInfo.IsStatic && constructorInfo.GetParameters().Length == 0)
					summary = new Collection<XmlDocBlock> { new() { Inlines = { new XmlDocInline { Text = "The default constructor." } } } };
			}

			return summary;
		}

		private string GetShortSummaryMarkdown(XmlDocAssembly xmlDocAssembly, MemberInfo member, MarkdownContext context) =>
			ToMarkdown(GetSummary(xmlDocAssembly, member)?.FirstOrDefault()?.Inlines, context) ?? "";

		private static string GetAssemblyUriName(Assembly assembly) => $"{assembly.GetName().Name}";

		private static string GetNamespaceUriName(string? namespaceName) => namespaceName ?? "global";

		private static string GetTypeUriName(TypeInfo typeInfo)
		{
			return GetFullTypeName(typeInfo, x =>
			{
				var genericTypeCount = x.GenericTypeParameters.Length;
				return GetShortName(x) + (genericTypeCount == 0 ? "" : $"-{genericTypeCount}");
			});
		}

		private string GetSafeTypeUriName(TypeInfo typeInfo)
		{
			var name = GetSafeName(GetTypeUriName(typeInfo));
			if (PermalinkPretty)
			{
				// Jekyll doesn't allow "Foo.md" and a folder named "Foo" containing the method markdown files.
				// So we rename the type "FooType.md" to avoid this conflict.
				name += "Type";
			}
			return name;
		}

		private string GetSafeName(string name)
		{
			if (PermalinkPretty)
				return name.Replace(".", ""); // Jekyll can't handle dots in file name.

			return name;
		}

		private string GetMemberUriName(MemberInfo memberInfo)
		{
			var typeInfo = memberInfo as TypeInfo;
			return typeInfo != null ? $"{GetSafeTypeUriName(typeInfo)}" : GetShortName(memberInfo);
		}

		private static string GetShortSignatureMarkdown(ShortSignature shortSignature, string path) =>
			EscapeHtml($"{shortSignature.Prefix}[{shortSignature.Name}]({path}){shortSignature.Suffix}");

		private static string EscapeHtml(string value) =>
			value.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;").Replace("|", "&#x7C;");

		private static string SurroundCode(string value)
		{
			var backticks = new string('`', Regex.Matches(value, "`+").Cast<Match>().Select(x => x.Length).Concat(new[] { 0 }).Max() + 1);
			return backticks + value + backticks;
		}

		private NamedText WriteMemberPage(string path, string parent, string title, MemberInfo memberInfo, MarkdownContext context) =>
			WriteMemberPage(path, parent, title, new[] { memberInfo }, context);

		private string GetFileExtension() => PermalinkPretty ? "" : ".md";

		private string GetPermalink(string path)
		{
			if (PermalinkPretty)
			{
				// permalinks paths cannot end in .md
				var pos = path.LastIndexOf('.');
				if (pos > 0)
					path = path.Substring(0, pos);
			}
			return path.Replace("\\", "/");
		}

		private NamedText WriteMemberPage(string path, string parent, string title, IReadOnlyList<MemberInfo> memberGroup, MarkdownContext context)
		{
			var extension = GetFileExtension();

			return CreateNamedText(path, parent, title, writer =>
			{
				var relative = $"{GetPermalink(path)}";
				var front = GetFrontMatter(title, relative);
				if (!string.IsNullOrEmpty(front))
					writer.WriteLine(front!);

				for (var memberIndex = 0; memberIndex < memberGroup.Count; memberIndex++)
				{
					var memberInfo = memberGroup[memberIndex];
					var memberContext = new MarkdownContext(context, memberInfo, path);
					var typeInfo = memberInfo as TypeInfo;
					var typeKind = typeInfo == null ? default(TypeKind?) : GetTypeKind(typeInfo);

					if (memberIndex != 0)
						writer.WriteLine();

					writer.WriteLine($"# {EscapeHtml(GetMemberHeading(memberGroup, memberIndex))}");

					var xmlDocRef = XmlDocUtility.GetXmlDocRef(memberInfo);
					var xmlDocMember = memberContext.XmlDocAssembly.FindMember(xmlDocRef);

					var summary = GetSummary(xmlDocMember, memberInfo);
					if (summary != null && summary.Count != 0)
					{
						writer.WriteLine();
						writer.WriteLines(ToMarkdown(summary, memberContext));
					}

					var seeAlsoMembers = new List<MemberInfo>();
					if (xmlDocMember != null)
					{
						foreach (var seeAlsoInfo in xmlDocMember.SeeAlso)
						{
							var xmlDocName = seeAlsoInfo.Ref;
							if (xmlDocName != null && memberContext.MembersByXmlDocName.TryGetValue(xmlDocName, out var seeAlsoMember))
								seeAlsoMembers.Add(seeAlsoMember);
						}
					}

					writer.WriteLine();
					writer.WriteLine("```csharp");
					writer.WriteLine(GetFullSignature(memberInfo, seeAlsoMembers));
					writer.WriteLine("```");

					if (xmlDocMember != null)
					{
						var typeParameters = xmlDocMember.TypeParameters;
						var parameters = xmlDocMember.Parameters;

						// record parameters are documented by the constructor, so don't repeat them here
						if (typeKind == TypeKind.Record)
							parameters = new Collection<XmlDocParameter>();

						if (typeParameters.Count + parameters.Count > 0)
						{
							writer.WriteLine();
							writer.WriteLine("| parameter | description |");
							writer.WriteLine("| --- | --- |");
							foreach (var typeParameter in typeParameters)
							{
								var description = ToMarkdown(typeParameter.Description.FirstOrDefault()?.Inlines, memberContext) ?? "";
								writer.WriteLine($"| {typeParameter.Name} | {description} |");
							}
							foreach (var parameter in parameters)
							{
								var description = ToMarkdown(parameter.Description.FirstOrDefault()?.Inlines, memberContext) ?? "";
								writer.WriteLine($"| {parameter.Name} | {description} |");
							}
						}
					}

					if (typeKind == TypeKind.Enum)
					{
						writer.WriteLine();
						writer.WriteLine("## Values");
						writer.WriteLine();
						writer.WriteLine("| name | value | description |");
						writer.WriteLine("| --- | --- | --- |");

						var isFlags = IsFlagsEnum(typeInfo!);
						foreach (var enumValue in typeInfo!.DeclaredMembers.OfType<FieldInfo>().Where(x => x.IsPublic && x.IsLiteral))
						{
							var valueObject = enumValue.GetValue(null);
							var valueText = isFlags ? "0x" + Convert.ToString(Convert.ToInt64(valueObject, CultureInfo.InvariantCulture), 16).ToUpperInvariant() :
								Enum.GetUnderlyingType(typeInfo.AsType()) == typeof(ulong) ? Convert.ToString(Convert.ToUInt64(valueObject, CultureInfo.InvariantCulture), CultureInfo.InvariantCulture) :
								Convert.ToString(Convert.ToInt64(valueObject, CultureInfo.InvariantCulture), CultureInfo.InvariantCulture);
							var description = GetShortSummaryMarkdown(memberContext.XmlDocAssembly, enumValue, memberContext);
							writer.WriteLine($"| {enumValue.Name} | {SurroundCode(valueText)} | {description} |");
						}
					}
					else if (typeKind is TypeKind.Record or TypeKind.Class or TypeKind.Struct or TypeKind.Interface)
					{
						var innerMemberVisibilityGroups = typeInfo!
							.DeclaredMembers
							.Where(IsVisible)
							.GroupBy(GetVisibility)
							.Select(tg => new
							{
								Visibility = tg.Key,
								Members = tg.ToList(),
							})
							.OrderByDescending(x => (int) x.Visibility);
						foreach (var innerMemberVisibilityGroup in innerMemberVisibilityGroups)
						{
							var innerMemberSignatureGroups = OrderMembers(innerMemberVisibilityGroup
								.Members
								.GroupBy(x => GetShortSignature(x))
								.Select(tg => new
								{
									ShortSignature = tg.Key,
									Members = tg.OrderBy(x => (x as TypeInfo)?.GenericTypeParameters.Length ?? 0).ToList(),
								}), x => x.Members[0]).ToList();

							if (innerMemberSignatureGroups.Count != 0)
							{
								writer.WriteLine();
								switch (innerMemberVisibilityGroup.Visibility)
								{
									case XmlDocVisibilityLevel.Public:
										writer.WriteLine(typeKind == TypeKind.Interface ? "## Members" : "## Public Members");
										break;
									case XmlDocVisibilityLevel.Protected:
										writer.WriteLine("## Protected Members");
										break;
									case XmlDocVisibilityLevel.Internal:
										writer.WriteLine("## Internal Members");
										break;
									case XmlDocVisibilityLevel.Private:
										writer.WriteLine("## Private Members");
										break;
									default:
										throw new InvalidOperationException();
								}
								writer.WriteLine();
								writer.WriteLine("| name | description |");
								writer.WriteLine("| --- | --- |");

								foreach (var innerMemberGroup in innerMemberSignatureGroups)
								{
									var innerMembers = innerMemberGroup.Members;
									var firstInnerMember = innerMembers[0];
									var memberPath = firstInnerMember is TypeInfo ?
										$"{GetMemberUriName(firstInnerMember)}{extension}" :
										$"{GetTypeUriName(typeInfo)}/{GetMemberUriName(firstInnerMember)}{extension}";
									var memberText = GetShortSignatureMarkdown(innerMemberGroup.ShortSignature, memberPath);
									var summaryText = GetShortSummaryMarkdown(memberContext.XmlDocAssembly, firstInnerMember, memberContext);
									if (innerMembers.Count != 1)
										summaryText += $" ({innerMembers.Count} {GetMemberGroupNoun(innerMembers)})";

									writer.WriteLine($"| {memberText} | {summaryText} |");
								}
							}
						}
					}

					var returnValue = xmlDocMember?.ReturnValue;
					if (returnValue != null && returnValue.Count != 0)
					{
						writer.WriteLine();
						writer.WriteLine("## Return Value");
						writer.WriteLine();
						writer.WriteLines(ToMarkdown(returnValue, memberContext));
					}

					var propertyValue = xmlDocMember?.PropertyValue;
					if (propertyValue != null && propertyValue.Count != 0)
					{
						writer.WriteLine();
						writer.WriteLine("## Property Value");
						writer.WriteLine();
						writer.WriteLines(ToMarkdown(propertyValue, memberContext));
					}

					var exceptions = xmlDocMember?.Exceptions;
					if (exceptions != null && exceptions.Count != 0)
					{
						writer.WriteLine();
						writer.WriteLine("## Exceptions");
						writer.WriteLine();
						writer.WriteLine("| exception | condition |");
						writer.WriteLine("| --- | --- |");

						foreach (var exception in exceptions)
						{
							MemberInfo? exceptionMemberInfo = null;
							if (exception.ExceptionTypeRef != null)
								memberContext.MembersByXmlDocName.TryGetValue(exception.ExceptionTypeRef, out exceptionMemberInfo);
							var text = exceptionMemberInfo != null ? GetShortName(exceptionMemberInfo) : exception.ExceptionTypeRef != null ? XmlDocUtility.GetShortNameForXmlDocRef(exception.ExceptionTypeRef) : "";
							var link = WrapMarkdownRefLink(text, exceptionMemberInfo, memberContext);
							writer.WriteLine($"| {link} | {ToMarkdown(exception.Condition.FirstOrDefault()?.Inlines, memberContext) ?? ""} |");
						}
					}

					var remarks = xmlDocMember?.Remarks;
					if (remarks != null && remarks.Count != 0)
					{
						writer.WriteLine();
						writer.WriteLine("## Remarks");
						writer.WriteLine();
						writer.WriteLines(ToMarkdown(remarks, memberContext));
					}

					var examples = xmlDocMember?.Examples;
					if (examples != null && examples.Count != 0)
					{
						writer.WriteLine();
						writer.WriteLine("## Examples");
						writer.WriteLine();
						writer.WriteLines(ToMarkdown(examples, memberContext));
					}

					writer.WriteLine();
					writer.WriteLine("## See Also");
					writer.WriteLine();

					var declaringType = memberInfo.DeclaringType?.GetTypeInfo();
					var declaringTypeXmlDocName = declaringType == null ? null : XmlDocUtility.GetXmlDocRef(declaringType);
					if (declaringType != null)
						seeAlsoMembers.Add(declaringType);

					foreach (var seeAlso in seeAlsoMembers
						.Where(x => XmlDocUtility.GetXmlDocRef(x) != xmlDocRef)
						.Select(GetGenericDefinition)
						.GroupBy(XmlDocUtility.GetXmlDocRef)
						.Select(x => new { Member = x.First(), XmlDocName = x.Key! })
						.OrderBy(x => x.XmlDocName == declaringTypeXmlDocName))
					{
						if (memberContext.MembersByXmlDocName.ContainsKey(seeAlso.XmlDocName!) ||
							FindExternalDocumentation(seeAlso.Member) != null)
						{
							var shortSignature = GetShortSignature(seeAlso.Member, forSeeAlso: true);
							writer.WriteLine("* " + shortSignature.Prefix +
								WrapMarkdownRefLink(shortSignature.Name, seeAlso.Member, memberContext) + shortSignature.Suffix);
						}
					}

					if (NamespacePages)
					{
						var namespacePath = GetPermalink(MakeRelative(path, parent));
						writer.WriteLine("* " + $"namespace\u00A0[{GetNamespaceName(declaringType ?? typeInfo!)}]({namespacePath}{extension})");

						var assemblyName = (declaringType ?? typeInfo!).Assembly.GetName().Name;
						var assemblyPath = GetPermalink(MakeRelative(path, RootPageLocation!));
						writer.WriteLine("* " + $"assembly\u00A0[{assemblyName}]({assemblyPath})");
					}
					else
					{
						writer.WriteLine("* " + $"namespace\u00A0[{GetNamespaceName(declaringType ?? typeInfo!)}](../{(typeInfo != null ? "" : "../")}{GetAssemblyUriName((declaringType ?? typeInfo!).Assembly)}{extension})");
					}

					if (typeInfo != null && declaringType == null && !string.IsNullOrEmpty(context.SourceCodePath) && !string.IsNullOrEmpty(context.RootNamespace))
					{
						var namespaceName = GetNamespaceName(typeInfo);
						if (namespaceName.StartsWith(context.RootNamespace, StringComparison.Ordinal))
						{
							var directoryPath = context.SourceCodePath + namespaceName.Substring(context.RootNamespace.Length).Replace('.', '/');
							if (!Uri.TryCreate(directoryPath, UriKind.Absolute, out _))
								directoryPath = "../" + directoryPath;
							var fileName = GetShortName(typeInfo) + ".cs";
							writer.WriteLine($"* [{fileName}]({directoryPath}/{fileName})");
						}
					}

					if (memberIndex < memberGroup.Count - 1)
					{
						writer.WriteLine();
						writer.WriteLine("---");
					}
				}

				writer.WriteLine();
				writer.WriteLine(GetCodeGenComment(context.AssemblyFileName));
			});
		}

		private ExternalDocumentation? FindExternalDocumentation(MemberInfo? memberInfo)
		{
			if (memberInfo == null)
				return null;

			var namespaceName = (memberInfo as TypeInfo ?? memberInfo.DeclaringType.GetTypeInfo()).Namespace;
			return ExternalDocs?.FirstOrDefault(x => x.Namespace == namespaceName);
		}

		private MemberInfo GetGenericDefinition(MemberInfo memberInfo)
		{
			var typeInfo = memberInfo as TypeInfo;
			if (typeInfo != null)
				return typeInfo.IsGenericType ? typeInfo.GetGenericTypeDefinition().GetTypeInfo() : typeInfo;

			var methodInfo = memberInfo as MethodInfo;
			if (methodInfo != null)
				return methodInfo.IsGenericMethod ? methodInfo.GetGenericMethodDefinition() : methodInfo;

			return memberInfo;
		}

		private bool IsVisible(MemberInfo memberInfo)
		{
			if (IsBuiltInRecordMember(memberInfo))
				return false;

			var visibility = GetVisibility(memberInfo);
			if (IsMorePrivateThan(visibility, Visibility))
				return false;

			if (!IncludeObsolete && memberInfo.GetCustomAttributes<ObsoleteAttribute>().Any())
				return false;

			if (memberInfo.GetCustomAttributes<CompilerGeneratedAttribute>().Any())
				return false;

			if (SkipUnbrowsable && memberInfo.GetCustomAttributes<EditorBrowsableAttribute>().Any(x => x.State == EditorBrowsableState.Never))
				return false;

			if (SkipCompilerGenerated && memberInfo.GetCustomAttributes<CompilerGeneratedAttribute>().Any())
				return false;

			var name = memberInfo.Name;
			if (name.Length == 0 || name[0] == '<')
				return false;

			// nested types of invisible types are invisible
			if (memberInfo.DeclaringType != null && !IsVisible(memberInfo.DeclaringType))
				return false;

			if (memberInfo is TypeInfo)
				return true;

			var methodBase = memberInfo as MethodBase;
			if (methodBase == null)
				return true;

			if (memberInfo is ConstructorInfo)
				return true;

			if (!methodBase.IsSpecialName)
				return true;

			if (methodBase.Name.StartsWith("op_", StringComparison.Ordinal))
				return true;

			return false;
		}

		private static bool IsMorePrivateThan(XmlDocVisibilityLevel visibility1, XmlDocVisibilityLevel visibility2) => (int) visibility1 < (int) visibility2;

		public static XmlDocVisibilityLevel GetMostPublic(params XmlDocVisibilityLevel[] visibilityLevels) => (XmlDocVisibilityLevel) visibilityLevels.Max(x => (int) x);

		public static XmlDocVisibilityLevel GetMostPrivate(params XmlDocVisibilityLevel[] visibilityLevels) => (XmlDocVisibilityLevel) visibilityLevels.Min(x => (int) x);

		private static string GetMemberHeading(IReadOnlyList<MemberInfo> membersInfos, int index)
		{
			var heading = $"{GetFullMemberName(membersInfos[index])} {GetMemberGroupNoun(new[] { membersInfos[index] })}";
			if (membersInfos.Count > 1)
				heading += $" ({index + 1} of {membersInfos.Count})";
			return heading;
		}

		private static string GetMemberGroupNoun(IReadOnlyList<MemberInfo> memberInfos)
		{
			var plural = memberInfos.Count != 1;

			if (memberInfos.All(x => x is ConstructorInfo))
				return plural ? "constructors" : "constructor";
			if (memberInfos.All(x => (x as PropertyInfo)?.GetIndexParameters().Length > 0))
				return plural ? "indexers" : "indexer";
			if (memberInfos.All(x => x is PropertyInfo))
				return plural ? "properties" : "property";
			if (memberInfos.All(x => (x as MethodInfo)?.Name.StartsWith("op_", StringComparison.Ordinal) == true))
				return plural ? "operators" : "operator";
			if (memberInfos.All(x => x is MethodInfo))
				return plural ? "methods" : "method";
			if (memberInfos.All(x => x is EventInfo))
				return plural ? "events" : "event";
			if (memberInfos.All(x => x is FieldInfo))
				return plural ? "fields" : "field";
			if (memberInfos.All(x => x is TypeInfo))
				return GetTypeGroupNoun(memberInfos.Cast<TypeInfo>().ToList());
			return plural ? "members" : "member";
		}

		private static string GetTypeGroupNoun(IReadOnlyList<TypeInfo> typeInfos)
		{
			var plural = typeInfos.Count != 1;

			var typeKinds = typeInfos.Select(GetTypeKind).ToList();
			if (typeKinds.All(x => x == TypeKind.Record))
				return plural ? "records" : "record";
			if (typeKinds.All(x => x == TypeKind.Class))
				return plural ? "classes" : "class";
			if (typeKinds.All(x => x == TypeKind.Interface))
				return plural ? "interfaces" : "interface";
			if (typeKinds.All(x => x == TypeKind.Struct))
				return plural ? "structures" : "structure";
			if (typeKinds.All(x => x == TypeKind.Enum))
				return plural ? "enumerations" : "enumeration";
			if (typeKinds.All(x => x == TypeKind.Delegate))
				return plural ? "delegates" : "delegate";
			return plural ? "types" : "type";
		}

		private static string GetNamespaceName(TypeInfo typeInfo) => typeInfo.Namespace ?? "global";

		private static string GetShortName(MemberInfo memberInfo)
		{
			var name = memberInfo.Name;

			var tickIndex = name.IndexOf('`');
			if (tickIndex != -1)
				name = name.Substring(0, tickIndex);

			if (name == ".ctor" || name == ".cctor")
				name = GetShortName(memberInfo.DeclaringType.GetTypeInfo());
			else if (name == "op_UnaryPlus")
				name = "op_Addition";
			else if (name == "op_UnaryNegation")
				name = "op_Subtraction";

			return name;
		}

		private static string GetOperatorKeywordName(string name) =>
			name switch
			{
				"op_Addition" => "operator +",
				"op_BitwiseAnd" => "operator &",
				"op_BitwiseOr" => "operator |",
				"op_Decrement" => "operator --",
				"op_Division" => "operator /",
				"op_Equality" => "operator ==",
				"op_ExclusiveOr" => "operator ^",
				"op_Explicit" => "explicit operator",
				"op_False" => "operator false",
				"op_GreaterThan" => "operator >",
				"op_GreaterThanOrEqual" => "operator >=",
				"op_Implicit" => "implicit operator",
				"op_Increment" => "operator ++",
				"op_Inequality" => "operator !=",
				"op_LeftShift" => "operator <<",
				"op_LessThan" => "operator <",
				"op_LessThanOrEqual" => "operator <=",
				"op_LogicalNot" => "operator !",
				"op_Modulus" => "operator %",
				"op_Multiply" => "operator *",
				"op_OnesComplement" => "operator ~",
				"op_RightShift" => "operator >>",
				"op_Subtraction" => "operator -",
				"op_True" => "operator true",
				"op_UnaryNegation" => "operator -",
				"op_UnaryPlus" => "operator +",
				_ => name,
			};

		private static string GetFullMemberName(MemberInfo memberInfo)
		{
			var type = memberInfo as TypeInfo;
			if (type != null)
				return GetFullTypeName(type, t => GetShortName(t) + RenderShortGenericParameters(t.GenericTypeParameters));

			if (memberInfo is ConstructorInfo || (memberInfo as PropertyInfo)?.GetIndexParameters().Length > 0)
				return GetFullTypeName(memberInfo.DeclaringType.GetTypeInfo(), t => GetShortName(t) + RenderShortGenericParameters(t.GenericTypeParameters));

			var methodName = (memberInfo as MethodInfo)?.Name;
			if (methodName?.StartsWith("op_", StringComparison.Ordinal) == true)
				return GetFullTypeName(memberInfo.DeclaringType.GetTypeInfo(), t => GetShortName(t) + RenderShortGenericParameters(t.GenericTypeParameters)) + " " + methodName.Substring(3);

			return GetFullTypeName(memberInfo.DeclaringType.GetTypeInfo(), t => GetShortName(t) + RenderShortGenericParameters(t.GenericTypeParameters)) + "." +
				GetShortName(memberInfo) + RenderShortGenericParameters(GetGenericArguments(memberInfo));
		}

		private static string GetFullTypeName(TypeInfo typeInfo, Func<TypeInfo, string> render)
		{
			var name = render(typeInfo);
			if (typeInfo.DeclaringType != null)
				name = $"{GetFullTypeName(typeInfo.DeclaringType.GetTypeInfo(), render)}.{name}";
			return name;
		}

		private sealed class ShortSignature : IEquatable<ShortSignature>
		{
			public ShortSignature(string prefix, string name, string suffix)
			{
				Prefix = prefix;
				Name = name;
				Suffix = suffix;
			}

			public string Prefix { get; }

			public string Name { get; }

			public string Suffix { get; }

			public bool Equals(ShortSignature? other) => other != null && other.ToString() == ToString();

			public override bool Equals(object? obj) => Equals(obj as ShortSignature);

			public override int GetHashCode() => ToString().GetHashCode();

			public override string ToString() => Prefix + Name + Suffix;
		}

		private ShortSignature GetShortSignature(MemberInfo memberInfo, bool forSeeAlso = false)
		{
			var name = GetOperatorKeywordName(GetShortName(memberInfo));
			var prefix = "";
			var suffix = "";

			var typeInfo = memberInfo as TypeInfo;
			if (typeInfo != null)
			{
				name += RenderShortGenericParameters(typeInfo.GenericTypeParameters);

				prefix = GetTypeKind(typeInfo) switch
				{
					TypeKind.Record => "record ",
					TypeKind.Class => "class ",
					TypeKind.Interface => "interface ",
					TypeKind.Struct => "struct ",
					TypeKind.Enum => "enum ",
					TypeKind.Delegate => "delegate ",
					_ => prefix,
				};

				if (!forSeeAlso)
				{
					if (IsFlagsEnum(typeInfo))
						prefix = "[Flags] " + prefix;
					if (IsStatic(typeInfo))
						prefix = "static " + prefix;
					else if (IsAbstract(typeInfo))
						prefix = "abstract " + prefix;
					else if (IsVirtual(typeInfo))
						prefix = "virtual " + prefix;
					else if (IsOverride(typeInfo))
						prefix = "override " + prefix;
				}
			}
			else
			{
				var eventInfo = memberInfo as EventInfo;
				var propertyInfo = memberInfo as PropertyInfo;
				var fieldInfo = memberInfo as FieldInfo;
				var methodBase = memberInfo as MethodBase;

				if (eventInfo != null)
				{
					prefix = "event ";
					if (!forSeeAlso)
					{
						if (IsStatic(eventInfo))
							prefix = "static " + prefix;
						else if (IsAbstract(eventInfo))
							prefix = "abstract " + prefix;
						else if (IsVirtual(eventInfo))
							prefix = "virtual " + prefix;
						else if (IsOverride(eventInfo))
							prefix = "override " + prefix;
					}
				}
				else if (propertyInfo != null)
				{
					if (!forSeeAlso)
						suffix = GetPropertyGetSet(propertyInfo);

					if (forSeeAlso)
						prefix = "property ";
					else if (IsStatic(propertyInfo))
						prefix = "static ";
					else if (IsAbstract(propertyInfo))
						prefix = "abstract ";
					else if (IsVirtual(propertyInfo))
						prefix = "virtual ";
					else if (IsOverride(propertyInfo))
						prefix = "override ";
				}
				else if (fieldInfo != null)
				{
					if (forSeeAlso)
					{
						prefix = "field ";
					}
					else
					{
						if (IsConst(fieldInfo))
							prefix += "const ";
						if (IsStatic(fieldInfo))
							prefix = "static ";
						if (IsReadOnly(fieldInfo))
							prefix += "readonly ";
					}
				}
				else if (methodBase != null)
				{
					var isOperator = methodBase.Name.StartsWith("op_", StringComparison.Ordinal);

					if (methodBase is MethodInfo)
						name += RenderShortGenericParameters(methodBase.GetGenericArguments());

					if (!forSeeAlso && !isOperator)
						suffix += methodBase.GetParameters().Length == 0 ? "()" : "(…)";

					if (forSeeAlso)
						prefix = "method ";
					else if (IsStatic(methodBase) && !isOperator)
						prefix = "static " + prefix;
					else if (IsAbstract(methodBase))
						prefix = "abstract " + prefix;
					else if (IsVirtual(methodBase))
						prefix = "virtual " + prefix;
					else if (IsOverride(methodBase))
						prefix = "override " + prefix;
				}
			}

			return new ShortSignature(prefix: prefix.Replace(' ', '\u00A0'), name: name, suffix: suffix.Replace(' ', '\u00A0'));
		}

		private string GetPropertyGetSet(PropertyInfo propertyInfo)
		{
			var getMethod = propertyInfo.GetMethod;
			var setMethod = propertyInfo.SetMethod;
			if (getMethod == null && setMethod == null)
				throw new InvalidOperationException();

			var getVisibility = getMethod == null ? XmlDocVisibilityLevel.Private : GetMethodVisibility(getMethod);
			var setVisibility = setMethod == null ? XmlDocVisibilityLevel.Private : GetMethodVisibility(setMethod);

			if (getMethod != null && (setMethod == null || IsMorePrivateThan(setVisibility, Visibility)))
				return " { get; }";
			if (getMethod == null || IsMorePrivateThan(getVisibility, Visibility))
				return " { set; }";

			if (getVisibility == setVisibility)
				return " { get; set; }";
			if (IsMorePrivateThan(getVisibility, setVisibility))
				return $" {{ {GetAccessModifier(getMethod)} get; set; }}";
			return $" {{ get; {GetAccessModifier(setMethod!)} set; }}";
		}

		private string GetFullSignature(MemberInfo memberInfo, ICollection<MemberInfo> seeAlsoMembers)
		{
			var stringBuilder = new StringBuilder();
			var lineBuilder = new StringBuilder();
			var segmentBuilder = new StringBuilder();
			const int maxLineLength = 100;

			void WrapLineIfNecessary(bool hard)
			{
				const string indent = "    ";

				if (lineBuilder.Length > indent.Length && (hard || lineBuilder.Length + segmentBuilder.Length > maxLineLength))
				{
					lineBuilder.Append(ActualNewLine);
					stringBuilder.Append(lineBuilder);
					lineBuilder.Clear();

					if (!hard)
						lineBuilder.Append(indent);
				}
			}

			foreach (var part in GetFullSignatureParts(memberInfo, seeAlsoMembers))
			{
				if (part.Length == 0 || part == ActualNewLine)
				{
					WrapLineIfNecessary(false);

					lineBuilder.Append(segmentBuilder);
					segmentBuilder.Clear();

					WrapLineIfNecessary(part == ActualNewLine);
				}
				else
				{
					segmentBuilder.Append(part);
				}
			}

			WrapLineIfNecessary(false);

			lineBuilder.Append(segmentBuilder);
			stringBuilder.Append(lineBuilder);
			return stringBuilder.ToString();
		}

		private IEnumerable<string> GetFullSignatureParts(MemberInfo memberInfo, ICollection<MemberInfo> seeAlsoMembers)
		{
			var typeInfo = memberInfo as TypeInfo;
			var typeKind = typeInfo == null ? default(TypeKind?) : GetTypeKind(typeInfo);

			var obsoleteAttribute = memberInfo.GetCustomAttribute<ObsoleteAttribute>();
			if (obsoleteAttribute != null)
			{
				var message = obsoleteAttribute.Message;
				if (string.IsNullOrWhiteSpace(message))
				{
					yield return "[Obsolete]";
				}
				else
				{
					yield return "[Obsolete(";
					yield return RenderConstant(message);
					yield return ")]";
				}
				yield return ActualNewLine;
			}

			var browsableAttribute = memberInfo.GetCustomAttribute<EditorBrowsableAttribute>();
			if (browsableAttribute != null && browsableAttribute.State != EditorBrowsableState.Always)
			{
				yield return "[EditorBrowsable(";
				yield return RenderConstant(browsableAttribute.State);
				yield return ")]";
				yield return ActualNewLine;
			}

			var attributeUsage = memberInfo.GetCustomAttribute<AttributeUsageAttribute>();
			if (attributeUsage != null)
			{
				yield return "[AttributeUsage(";

				yield return RenderConstant(attributeUsage.ValidOn);

				if (!attributeUsage.Inherited)
				{
					yield return ", ";
					yield return "";
					yield return "Inherited = false";
				}

				if (attributeUsage.AllowMultiple)
				{
					yield return ", ";
					yield return "";
					yield return "AllowMultiple = true";
				}

				yield return ")]";
				yield return ActualNewLine;
			}

			if (IsFlagsEnum(memberInfo))
			{
				yield return "[Flags]";
				yield return ActualNewLine;
			}

			yield return $"{GetAccessModifier(memberInfo)} ";

			if (IsStatic(memberInfo))
				yield return "static ";
			else if (typeKind == TypeKind.Class && typeInfo!.IsSealed)
				yield return "sealed ";
			else if (IsAbstract(memberInfo))
				yield return "abstract ";
			else if (IsVirtual(memberInfo))
				yield return "virtual ";
			else if (IsOverride(memberInfo))
				yield return "override ";

			if (IsConst(memberInfo))
				yield return "const ";
			if (IsReadOnly(memberInfo))
				yield return "readonly ";

			if (memberInfo is EventInfo)
				yield return "event ";

			switch (typeKind)
			{
				case TypeKind.Record:
					yield return "record ";
					break;
				case TypeKind.Class:
					yield return "class ";
					break;
				case TypeKind.Interface:
					yield return "interface ";
					break;
				case TypeKind.Struct:
					yield return "struct ";
					break;
				case TypeKind.Enum:
					yield return "enum ";
					break;
				case TypeKind.Delegate:
					yield return "delegate ";
					break;
			}

			var shortName = GetOperatorKeywordName(GetShortName(memberInfo));
			if (shortName == "Item" && memberInfo is PropertyInfo)
				shortName = "this";

			var isConversion = shortName == "explicit operator" || shortName == "implicit operator";

			var nullableContextFlags = GetNullableContextFlags(memberInfo.GetCustomAttributes());
			if (nullableContextFlags.Length == 0)
			{
				var ancestor = memberInfo;
				while (true)
				{
					ancestor = ancestor.DeclaringType?.GetTypeInfo();
					if (ancestor is null)
						break;
					nullableContextFlags = GetNullableContextFlags(ancestor.GetCustomAttributes());
					if (nullableContextFlags.Length != 0)
						break;
				}
			}

			var (valueType, valueAttributes) = GetValueType(memberInfo);
			if (valueType != null && !isConversion)
			{
				yield return RenderTypeName(valueType, seeAlsoMembers, valueAttributes, nullableContextFlags);
				yield return " ";
			}

			if (valueType != null && isConversion)
			{
				yield return shortName;
				yield return " ";
				yield return RenderTypeName(valueType, seeAlsoMembers, valueAttributes, nullableContextFlags);
			}
			else
			{
				yield return "";
				yield return shortName;
			}

			var genericParameters = GetGenericArguments(memberInfo);
			if (genericParameters.Length != 0)
				yield return RenderGenericParameters(genericParameters);

			if (typeKind is TypeKind.Record or TypeKind.Class or TypeKind.Struct or TypeKind.Interface)
			{
				var isFirstBase = true;
				if (typeKind == TypeKind.Class && typeInfo!.BaseType != typeof(object))
				{
					yield return " : ";
					yield return "";
					yield return RenderTypeName(typeInfo.BaseType.GetTypeInfo(), seeAlsoMembers);
					isFirstBase = false;
				}

				var baseInterfaces = typeInfo!.ImplementedInterfaces.Select(x => x.GetTypeInfo())
					.Where(x => x.IsPublic)
					.OrderBy(x => x.Name, StringComparer.OrdinalIgnoreCase)
					.ThenBy(x => x.IsGenericType ? x.GenericTypeArguments.Length : 0)
					.ThenBy(x => x.IsGenericType ? RenderGenericArguments(x.GenericTypeArguments) : "", StringComparer.OrdinalIgnoreCase)
					.ToList();
				var baseTypeInterfaces = typeInfo.BaseType?.GetTypeInfo().ImplementedInterfaces.Select(x => x.GetTypeInfo()).ToList();
				foreach (var baseInterface in baseInterfaces)
				{
					if (!(typeKind == TypeKind.Class && baseTypeInterfaces!.Contains(baseInterface)) &&
						!baseInterfaces.Any(x => XmlDocUtility.GetXmlDocRef(x) != XmlDocUtility.GetXmlDocRef(baseInterface) && IsLessDerived(baseInterface, x)) &&
						!(typeKind == TypeKind.Record && baseInterface.Name == "IEquatable`1" && baseInterface.GenericTypeArguments[0] == typeInfo.AsType()))
					{
						yield return isFirstBase ? " : " : ", ";
						yield return "";
						yield return RenderTypeName(baseInterface, seeAlsoMembers);
						isFirstBase = false;
					}
				}
			}

			if (typeKind == TypeKind.Enum && Enum.GetUnderlyingType(typeInfo!.AsType()) != typeof(int))
			{
				yield return " : ";
				yield return RenderTypeName(Enum.GetUnderlyingType(typeInfo.AsType()).GetTypeInfo(), seeAlsoMembers);
			}

			ParameterInfo[]? parameterInfos = null;

			var propertyInfo = memberInfo as PropertyInfo;
			if (propertyInfo != null)
			{
				parameterInfos = GetParameters(propertyInfo);
				if (parameterInfos.Length == 0)
					parameterInfos = null;
			}

			var methodInfo = memberInfo as MethodBase ?? TryGetDelegateInvoke(memberInfo);
			if (methodInfo != null)
				parameterInfos = GetParameters(methodInfo);

			if (parameterInfos != null)
			{
				yield return propertyInfo != null ? "[" : "(";
				yield return "";

				var isFirstParameter = true;
				foreach (var (parameterInfo, index) in parameterInfos.Select((x, i) => (x, i)))
				{
					if (!isFirstParameter)
					{
						yield return ", ";
						yield return "";
					}

					if (parameterInfo.GetCustomAttributes<CallerFilePathAttribute>().Any())
						yield return "[CallerFilePath] ";
					if (parameterInfo.GetCustomAttributes<CallerLineNumberAttribute>().Any())
						yield return "[CallerLineNumber] ";
					if (parameterInfo.GetCustomAttributes<CallerMemberNameAttribute>().Any())
						yield return "[CallerMemberName] ";

					if (isFirstParameter && IsStatic(memberInfo) && memberInfo.GetCustomAttributes<ExtensionAttribute>().Any())
						yield return "this ";

					if (parameterInfo.ParameterType.IsByRef)
						yield return parameterInfo.IsOut ? "out " : "ref ";
					if (parameterInfo.GetCustomAttributes<ParamArrayAttribute>().Any())
						yield return "params ";

					yield return RenderTypeName(parameterInfo.ParameterType.GetTypeInfo(),
						seeAlso: seeAlsoMembers,
						attributes: parameterInfo.GetCustomAttributes().ToList(),
						nullableContextFlags: nullableContextFlags);

					yield return " ";
					if (IsKeyword(parameterInfo.Name))
						yield return "@";
					yield return parameterInfo.Name ?? "P_" + index.ToString(CultureInfo.InvariantCulture); // default as per ILSpy if null

					if (ParameterHasDefaultValue(parameterInfo))
					{
						yield return " = ";
						if (CanRenderParameterConstant(parameterInfo))
							yield return RenderConstant(parameterInfo.DefaultValue);
						else if (parameterInfo.ParameterType.GetTypeInfo().IsValueType || parameterInfo.ParameterType.IsGenericParameter)
							yield return "default";
						else
							yield return "null";
					}

					isFirstParameter = false;
				}

				yield return propertyInfo != null ? "]" : ")";
			}

			if (propertyInfo != null)
				yield return GetPropertyGetSet(propertyInfo);

			foreach (var genericParameter in genericParameters)
			{
				var isFirstPart = true;

				if (genericParameter.GetTypeInfo().GenericParameterAttributes.HasFlag(GenericParameterAttributes.ReferenceTypeConstraint))
				{
					yield return ActualNewLine;
					yield return $"    where {genericParameter.Name} : ";

					yield return "class";
					isFirstPart = false;
				}

				var isStruct = genericParameter.GetTypeInfo().GenericParameterAttributes.HasFlag(GenericParameterAttributes.NotNullableValueTypeConstraint);
				if (isStruct)
				{
					if (isFirstPart)
					{
						yield return ActualNewLine;
						yield return $"    where {genericParameter.Name} : ";
					}
					else
					{
						yield return ", ";
					}

					yield return "struct";
					isFirstPart = false;
				}

				var genericConstraints = genericParameter.GetTypeInfo().GetGenericParameterConstraints();
				foreach (var genericConstraint in genericConstraints.Where(x => x != typeof(ValueType)))
				{
					if (isFirstPart)
					{
						yield return ActualNewLine;
						yield return $"    where {genericParameter.Name} : ";
					}
					else
					{
						yield return ", ";
					}

					yield return RenderTypeName(genericConstraint.GetTypeInfo(), seeAlsoMembers);
					isFirstPart = false;
				}

				if (!isStruct && genericParameter.GetTypeInfo().GenericParameterAttributes.HasFlag(GenericParameterAttributes.DefaultConstructorConstraint))
				{
					if (isFirstPart)
					{
						yield return ActualNewLine;
						yield return $"    where {genericParameter.Name} : ";
					}
					else
					{
						yield return ", ";
					}

					yield return "new()";
				}
			}

			if (typeKind == TypeKind.Delegate || memberInfo is EventInfo || memberInfo is FieldInfo)
				yield return ";";
		}

		private static (TypeInfo? Type, IReadOnlyList<Attribute>? Attributes) GetValueType(MemberInfo member)
		{
			var eventInfo = member as EventInfo;
			if (eventInfo != null)
				return (eventInfo.EventHandlerType.GetTypeInfo(), eventInfo.GetCustomAttributes().ToList());

			var propertyInfo = member as PropertyInfo;
			if (propertyInfo != null)
				return (propertyInfo.PropertyType.GetTypeInfo(), propertyInfo.GetCustomAttributes().ToList());

			var fieldInfo = member as FieldInfo;
			if (fieldInfo != null)
				return (fieldInfo.FieldType.GetTypeInfo(), fieldInfo.GetCustomAttributes().ToList());

			var methodInfo = member as MethodInfo ?? TryGetDelegateInvoke(member);
			if (methodInfo != null)
				return (methodInfo.ReturnType.GetTypeInfo(), methodInfo.ReturnTypeCustomAttributes.GetCustomAttributes(inherit: false).OfType<Attribute>().ToList());

			return default;
		}

		private static byte[] GetNullableContextFlags(IEnumerable<Attribute> attributes)
		{
			var attribute = attributes.FirstOrDefault(x => x.GetType().FullName == "System.Runtime.CompilerServices.NullableContextAttribute");
			return attribute is null ? Array.Empty<byte>() : new[] { (byte) attribute.GetType().GetField("Flag").GetValue(attribute) };
		}

		private static byte[] GetNullableFlags(IEnumerable<Attribute> attributes)
		{
			var attribute = attributes.FirstOrDefault(x => x.GetType().FullName == "System.Runtime.CompilerServices.NullableAttribute");
			return ((byte[]?) attribute?.GetType().GetField("NullableFlags").GetValue(attribute)) ?? Array.Empty<byte>();
		}

		private static bool ParameterHasDefaultValue(ParameterInfo parameterInfo)
		{
			if (parameterInfo.Attributes.HasFlag(ParameterAttributes.HasDefault))
				return true;

			if (parameterInfo.ParameterType == typeof(decimal) || parameterInfo.ParameterType == typeof(decimal?))
				return parameterInfo.HasDefaultValue;

			return false;
		}

		private static bool CanRenderParameterConstant(ParameterInfo parameterInfo)
		{
			return TryGetBuiltInTypeName(parameterInfo.ParameterType) != null ||
				TryGetBuiltInTypeName(Nullable.GetUnderlyingType(parameterInfo.ParameterType)) != null ||
				parameterInfo.ParameterType.GetTypeInfo().IsEnum;
		}

		private static string RenderConstant(object value)
		{
			if (value == null)
				return "null";

			if (value is bool valueAsBool)
				return valueAsBool ? "true" : "false";

			if (value is char valueAsChar)
				return RenderChar(valueAsChar);

			if (value is string valueAsString)
				return RenderString(valueAsString);

			var type = value.GetType();
			if (type.GetTypeInfo().IsEnum)
			{
				return string.Join(" | ", value.ToString()
					.Split(new[] { ", " }, StringSplitOptions.None)
					.Select(x => $"{type.Name}.{x}"));
			}

			var rendered = Convert.ToString(value, CultureInfo.InvariantCulture);

			if (value is double)
				rendered += "m";

			return rendered;
		}

		private static string RenderString(string value)
		{
			var builder = new StringBuilder("\"");
			foreach (var ch in value)
				builder.Append(ch == '\'' ? "'" : EscapeChar(ch));
			return builder.Append('"').ToString();
		}

		private static string RenderChar(char ch) => "'" + (ch == '\"' ? "\"" : EscapeChar(ch)) + "'";

		private static string EscapeChar(char ch) =>
			ch switch
			{
				'\'' => @"\'",
				'\"' => @"\""",
				'\\' => @"\\",
				'\a' => @"\a",
				'\b' => @"\b",
				'\f' => @"\f",
				'\n' => @"\n",
				'\r' => @"\r",
				'\t' => @"\t",
				'\v' => @"\v",
				_ => char.IsControl(ch) ? $"\\u{(int) ch:x4}" : ch.ToString(),
			};

		private static string RenderGenericParameters(Type[] genericParameters)
		{
			var stringBuilder = new StringBuilder();
			for (var index = 0; index < genericParameters.Length; index++)
			{
				var genericParameter = genericParameters[index];
				stringBuilder.Append((index == 0 ? "<" : "") +
					(genericParameter.GetTypeInfo().GenericParameterAttributes.HasFlag(GenericParameterAttributes.Covariant) ? "out " : "") +
					(genericParameter.GetTypeInfo().GenericParameterAttributes.HasFlag(GenericParameterAttributes.Contravariant) ? "in " : "") +
					genericParameter.Name +
					(index < genericParameters.Length - 1 ? ", " : "") +
					(index == genericParameters.Length - 1 ? ">" : ""));
			}
			return stringBuilder.ToString();
		}

		private static string RenderShortGenericParameters(Type[] genericParameters)
		{
			if (genericParameters == null)
				return "";

			var stringBuilder = new StringBuilder();
			for (var index = 0; index < genericParameters.Length; index++)
			{
				var genericParameter = genericParameters[index];
				stringBuilder.Append((index == 0 ? "<" : "") +
					genericParameter.Name +
					(index < genericParameters.Length - 1 ? "," : "") +
					(index == genericParameters.Length - 1 ? ">" : ""));
			}
			return stringBuilder.ToString();
		}

		private static string RenderTypeName(TypeInfo typeInfo, ICollection<MemberInfo>? seeAlso = null, IReadOnlyList<Attribute>? attributes = null, byte[]? nullableContextFlags = null)
		{
			attributes ??= Array.Empty<Attribute>();
			var tupleNames = GetTupleNames(attributes);
			var tupleNameIndex = 0;
			var nullableFlags = GetNullableFlags(attributes);
			if (nullableFlags.Length == 0)
				nullableFlags = nullableContextFlags ?? Array.Empty<byte>();
			var nullableFlagIndex = 0;
			return RenderTypeName(typeInfo, seeAlso, tupleNames, ref tupleNameIndex, nullableFlags, ref nullableFlagIndex);
		}

		private static string RenderTypeName(TypeInfo typeInfo, ICollection<MemberInfo>? seeAlso, IReadOnlyList<string?> tupleNames, ref int tupleNameIndex, byte[] nullableFlags, ref int nullableFlagIndex)
		{
			if (typeInfo.IsByRef)
				return RenderTypeName(typeInfo.GetElementType().GetTypeInfo(), seeAlso, tupleNames, ref tupleNameIndex, nullableFlags, ref nullableFlagIndex);

			var nullableOfType = Nullable.GetUnderlyingType(typeInfo.AsType());
			if (nullableOfType != null)
				return $"{RenderTypeName(nullableOfType.GetTypeInfo(), seeAlso, tupleNames, ref tupleNameIndex, nullableFlags, ref nullableFlagIndex)}?";

			var nullableSuffix = "";
			if (!typeInfo.IsValueType || typeInfo.IsGenericType)
			{
				if (nullableFlagIndex < nullableFlags.Length && nullableFlags[nullableFlagIndex] == 2)
					nullableSuffix = "?";
				if (nullableFlagIndex < nullableFlags.Length - 1)
					nullableFlagIndex++;
			}

			if (typeInfo.IsArray)
				return $"{RenderTypeName(typeInfo.GetElementType().GetTypeInfo(), seeAlso, tupleNames, ref tupleNameIndex, nullableFlags, ref nullableFlagIndex)}[]" + nullableSuffix;

			var builtIn = TryGetBuiltInTypeName(typeInfo.AsType());
			if (builtIn != null)
				return builtIn + nullableSuffix;

			var renderedTupleTypes = RenderTupleTypes(typeInfo, seeAlso, tupleNames, ref tupleNameIndex, nullableFlags, ref nullableFlagIndex);
			if (renderedTupleTypes.Count > 1)
				return $"({string.Join(", ", renderedTupleTypes)})";

			seeAlso?.Add(typeInfo);

			return GetShortName(typeInfo) + RenderGenericArguments(typeInfo.GenericTypeArguments, seeAlso, tupleNames, ref tupleNameIndex, nullableFlags, ref nullableFlagIndex) + nullableSuffix;
		}

		private static IReadOnlyList<string> RenderTupleTypes(TypeInfo typeInfo, ICollection<MemberInfo>? seeAlso, IReadOnlyList<string?> tupleNames, ref int tupleNameIndex, byte[] nullableFlags, ref int nullableFlagIndex)
		{
			var renderedTupleTypes = new List<string>();

			if (typeInfo.Namespace == "System" && typeInfo.Name.StartsWith("ValueTuple`", StringComparison.Ordinal))
			{
				var ourTupleNameIndex = tupleNameIndex;
				tupleNameIndex += CountTupleItems(typeInfo);

				var genericTypeArguments = typeInfo.GenericTypeArguments;
				while (true)
				{
					foreach (var genericTypeArgument in genericTypeArguments.Take(7))
					{
						var itemType = genericTypeArgument.GetTypeInfo();
						var renderedTupleType = RenderTypeName(itemType, seeAlso, tupleNames, ref tupleNameIndex, nullableFlags, ref nullableFlagIndex);
						var itemName = tupleNames.ElementAtOrDefault(ourTupleNameIndex++);
						if (itemName is not null)
							renderedTupleType += $" {itemName}";
						renderedTupleTypes.Add(renderedTupleType);
					}

					if (genericTypeArguments.Length < 8)
						break;

					genericTypeArguments = genericTypeArguments[7].GenericTypeArguments;
					tupleNameIndex++;
				}
			}

			return renderedTupleTypes;
		}

		private static int CountTupleItems(TypeInfo typeInfo) =>
			typeInfo.GenericTypeArguments.Length < 8 ? typeInfo.GenericTypeArguments.Length : 7 + CountTupleItems(typeInfo.GenericTypeArguments[7].GetTypeInfo());

		private static IReadOnlyList<string?> GetTupleNames(IEnumerable<Attribute> attributes) =>
			attributes.OfType<TupleElementNamesAttribute>().FirstOrDefault()?.TransformNames as IReadOnlyList<string?> ?? Array.Empty<string?>();

		private static string RenderGenericArguments(Type[]? genericArguments, ICollection<MemberInfo>? seeAlso = null)
		{
			var tupleNameIndex = 0;
			var nullableFlagIndex = 0;
			return RenderGenericArguments(genericArguments, seeAlso, Array.Empty<string?>(), ref tupleNameIndex, Array.Empty<byte>(), ref nullableFlagIndex);
		}

		private static string RenderGenericArguments(Type[]? genericArguments, ICollection<MemberInfo>? seeAlso, IReadOnlyList<string?> tupleNames, ref int tupleNameIndex, byte[] nullableFlags, ref int nullableFlagIndex)
		{
			if (genericArguments == null)
				return "";

			var stringBuilder = new StringBuilder();
			for (var index = 0; index < genericArguments.Length; index++)
			{
				var genericArgument = genericArguments[index];
				stringBuilder.Append((index == 0 ? "<" : "") +
					RenderTypeName(genericArgument.GetTypeInfo(), seeAlso, tupleNames, ref tupleNameIndex, nullableFlags, ref nullableFlagIndex) +
					(index < genericArguments.Length - 1 ? ", " : "") +
					(index == genericArguments.Length - 1 ? ">" : ""));
			}
			return stringBuilder.ToString();
		}

		private static string? TryGetBuiltInTypeName(Type type)
		{
			if (type == typeof(void))
				return "void";
			if (type == typeof(bool))
				return "bool";
			if (type == typeof(byte))
				return "byte";
			if (type == typeof(sbyte))
				return "sbyte";
			if (type == typeof(char))
				return "char";
			if (type == typeof(decimal))
				return "decimal";
			if (type == typeof(double))
				return "double";
			if (type == typeof(float))
				return "float";
			if (type == typeof(int))
				return "int";
			if (type == typeof(uint))
				return "uint";
			if (type == typeof(long))
				return "long";
			if (type == typeof(ulong))
				return "ulong";
			if (type == typeof(object))
				return "object";
			if (type == typeof(short))
				return "short";
			if (type == typeof(ushort))
				return "ushort";
			if (type == typeof(string))
				return "string";
			return null;
		}

		private static bool IsStatic(MemberInfo memberInfo)
		{
			var typeInfo = memberInfo as TypeInfo;
			if (typeInfo != null)
				return typeInfo.IsClass && typeInfo.IsAbstract && typeInfo.IsSealed;

			var eventInfo = memberInfo as EventInfo;
			if (eventInfo != null)
				return eventInfo.AddMethod.IsStatic;

			var propertyInfo = memberInfo as PropertyInfo;
			if (propertyInfo != null)
				return (propertyInfo.GetMethod ?? propertyInfo.SetMethod)?.IsStatic ?? false;

			var fieldInfo = memberInfo as FieldInfo;
			if (fieldInfo != null)
				return fieldInfo.IsStatic && !fieldInfo.IsLiteral;

			var methodBase = memberInfo as MethodBase;
			if (methodBase != null)
				return methodBase.IsStatic;

			return false;
		}

		private static bool IsAbstract(MemberInfo memberInfo)
		{
			var typeInfo = memberInfo as TypeInfo;
			if (typeInfo != null && !typeInfo.IsInterface)
				return typeInfo.IsAbstract;

			if (memberInfo.DeclaringType?.GetTypeInfo().IsInterface == true)
				return false;

			var eventInfo = memberInfo as EventInfo;
			if (eventInfo != null)
				return eventInfo.AddMethod != null && IsAbstract(eventInfo.AddMethod);

			var propertyInfo = memberInfo as PropertyInfo;
			if (propertyInfo != null)
			{
				return (propertyInfo.GetMethod != null && IsAbstract(propertyInfo.GetMethod)) ||
					(propertyInfo.SetMethod != null && IsAbstract(propertyInfo.SetMethod));
			}

			var methodBase = memberInfo as MethodBase;
			if (methodBase != null)
				return methodBase.IsAbstract;

			return false;
		}

		private static bool IsVirtual(MemberInfo memberInfo)
		{
			if (memberInfo.DeclaringType?.GetTypeInfo().IsInterface == true)
				return false;

			var eventInfo = memberInfo as EventInfo;
			if (eventInfo != null)
				return eventInfo.AddMethod != null && IsVirtual(eventInfo.AddMethod);

			var propertyInfo = memberInfo as PropertyInfo;
			if (propertyInfo != null)
			{
				return (propertyInfo.GetMethod != null && IsVirtual(propertyInfo.GetMethod)) ||
					(propertyInfo.SetMethod != null && IsVirtual(propertyInfo.SetMethod));
			}

			var methodInfo = memberInfo as MethodInfo;
			if (methodInfo != null)
				return methodInfo.IsVirtual && !methodInfo.IsFinal && methodInfo.GetRuntimeBaseDefinition().DeclaringType == methodInfo.DeclaringType;

			return false;
		}

		private static bool IsOverride(MemberInfo memberInfo)
		{
			if (memberInfo.DeclaringType?.GetTypeInfo().IsInterface == true)
				return false;

			var eventInfo = memberInfo as EventInfo;
			if (eventInfo != null)
				return eventInfo.AddMethod != null && IsOverride(eventInfo.AddMethod);

			var propertyInfo = memberInfo as PropertyInfo;
			if (propertyInfo != null)
			{
				return (propertyInfo.GetMethod != null && IsOverride(propertyInfo.GetMethod)) ||
					(propertyInfo.SetMethod != null && IsOverride(propertyInfo.SetMethod));
			}

			var methodInfo = memberInfo as MethodInfo;
			if (methodInfo != null)
				return methodInfo.IsVirtual && !methodInfo.IsFinal && methodInfo.GetRuntimeBaseDefinition().DeclaringType != methodInfo.DeclaringType;

			return false;
		}

		private static bool IsConst(MemberInfo memberInfo) => (memberInfo as FieldInfo)?.IsLiteral ?? false;

		private static bool IsReadOnly(MemberInfo memberInfo) => (memberInfo as FieldInfo)?.IsInitOnly ?? false;

		private static bool IsFlagsEnum(MemberInfo memberInfo)
		{
			var type = memberInfo as TypeInfo;
			return type != null && type.IsEnum && type.GetCustomAttributes<FlagsAttribute>().Any();
		}

		private static bool IsRecord(Type type) => type.GetMethod("<Clone>$") != null;

		private static bool IsBuiltInRecordMember(MemberInfo memberInfo)
		{
			if (memberInfo.DeclaringType is not Type declaringType || !IsRecord(declaringType))
				return false;

			return memberInfo switch
			{
				MethodInfo method => method.Name is "<Clone>$" or "Deconstruct" or "Equals" or "GetHashCode" or "op_Equality" or "op_Inequality" or "PrintMembers" or "ToString",
				PropertyInfo property => property.Name is "EqualityContract",
				ConstructorInfo constructor => !constructor.IsPublic && constructor.GetParameters().Select(x => x.ParameterType).SequenceEqual(new[] { declaringType }),
				_ => false,
			};
		}

		private static XmlDocVisibilityLevel GetVisibility(MemberInfo memberInfo) => GetVisibility(memberInfo, XmlDocVisibilityLevel.Protected);

		private static XmlDocVisibilityLevel GetVisibility(MemberInfo memberInfo, XmlDocVisibilityLevel protectedInternal)
		{
			var typeInfo = memberInfo as TypeInfo;
			if (typeInfo != null)
			{
				var visibility = GetTypeVisibility(typeInfo);
				return typeInfo.IsNested ? GetMostPrivate(visibility, GetTypeVisibility(typeInfo.DeclaringType.GetTypeInfo(), protectedInternal)) : visibility;
			}

			var eventInfo = memberInfo as EventInfo;
			if (eventInfo != null)
				return GetMethodVisibility(eventInfo.AddMethod, protectedInternal);

			var propertyInfo = memberInfo as PropertyInfo;
			if (propertyInfo != null)
				return GetPropertyVisibility(propertyInfo, protectedInternal);

			var fieldInfo = memberInfo as FieldInfo;
			if (fieldInfo != null)
				return GetFieldVisibility(fieldInfo, protectedInternal);

			var methodBase = memberInfo as MethodBase;
			if (methodBase != null)
				return GetMethodVisibility(methodBase, protectedInternal);

			return XmlDocVisibilityLevel.Private;
		}

		private static XmlDocVisibilityLevel GetTypeVisibility(TypeInfo typeInfo, XmlDocVisibilityLevel protectedInternal = XmlDocVisibilityLevel.Protected)
		{
			if (typeInfo.IsPublic || typeInfo.IsNestedPublic)
				return XmlDocVisibilityLevel.Public;
			if (typeInfo.IsNestedFamORAssem)
				return protectedInternal;
			if (typeInfo.IsNestedFamily)
				return XmlDocVisibilityLevel.Protected;
			if (typeInfo.IsNestedAssembly || typeInfo.IsNestedFamANDAssem)
				return XmlDocVisibilityLevel.Internal;
			return XmlDocVisibilityLevel.Private;
		}

		private static XmlDocVisibilityLevel GetMethodVisibility(MethodBase methodBase, XmlDocVisibilityLevel protectedInternal = XmlDocVisibilityLevel.Protected)
		{
			if (methodBase.IsPublic)
				return XmlDocVisibilityLevel.Public;
			if (methodBase.IsFamilyOrAssembly)
				return protectedInternal;
			if (methodBase.IsFamily)
				return XmlDocVisibilityLevel.Protected;
			if (methodBase.IsAssembly || methodBase.IsFamilyAndAssembly)
				return XmlDocVisibilityLevel.Internal;
			return XmlDocVisibilityLevel.Private;
		}

		private static XmlDocVisibilityLevel GetPropertyVisibility(PropertyInfo propertyInfo, XmlDocVisibilityLevel protectedInternal = XmlDocVisibilityLevel.Protected)
		{
			var getMethod = propertyInfo.GetMethod;
			var setMethod = propertyInfo.SetMethod;
			if (getMethod == null && setMethod == null)
				throw new InvalidOperationException();

			if (getMethod != null && setMethod == null)
				return GetMethodVisibility(getMethod);
			if (getMethod == null)
				return GetMethodVisibility(setMethod);

			return GetMostPublic(
				GetMethodVisibility(propertyInfo.GetMethod, protectedInternal),
				GetMethodVisibility(propertyInfo.SetMethod, protectedInternal));
		}

		private static XmlDocVisibilityLevel GetFieldVisibility(FieldInfo fieldInfo, XmlDocVisibilityLevel protectedInternal = XmlDocVisibilityLevel.Protected)
		{
			if (fieldInfo.IsPublic)
				return XmlDocVisibilityLevel.Public;
			if (fieldInfo.IsFamilyOrAssembly)
				return protectedInternal;
			if (fieldInfo.IsFamily)
				return XmlDocVisibilityLevel.Protected;
			if (fieldInfo.IsAssembly || fieldInfo.IsFamilyAndAssembly)
				return XmlDocVisibilityLevel.Internal;
			return XmlDocVisibilityLevel.Private;
		}

		private static string GetAccessModifier(MemberInfo memberInfo)
		{
			var visibility = GetVisibility(memberInfo, XmlDocVisibilityLevel.ProtectedInternal);
			return visibility switch
			{
				XmlDocVisibilityLevel.Public => "public",
				XmlDocVisibilityLevel.ProtectedInternal => "protected internal",
				XmlDocVisibilityLevel.Protected => "protected",
				XmlDocVisibilityLevel.Internal => "internal",
				XmlDocVisibilityLevel.Private => "private",
				_ => throw new InvalidOperationException(),
			};
		}

		private enum TypeKind
		{
			Unknown,
			Class,
			Interface,
			Struct,
			Enum,
			Delegate,
			Record,
		}

		private static TypeKind GetTypeKind(TypeInfo typeInfo)
		{
			if (typeof(Delegate).GetTypeInfo().IsAssignableFrom(typeInfo))
				return TypeKind.Delegate;
			if (IsRecord(typeInfo))
				return TypeKind.Record;
			if (typeInfo.IsClass)
				return TypeKind.Class;
			if (typeInfo.IsInterface)
				return TypeKind.Interface;
			if (typeInfo.IsEnum)
				return TypeKind.Enum;
			if (typeInfo.IsValueType)
				return TypeKind.Struct;
			return TypeKind.Unknown;
		}

		private enum MemberOrder
		{
			Constructor,
			LifetimeProperty,
			LifetimeField,
			LifetimeMethod,
			InstanceProperty,
			InstanceField,
			InstanceEvent,
			InstanceMethod,
			StaticProperty,
			StaticField,
			StaticEvent,
			StaticMethod,
			Operator,
			Type,
			Unknown,
		}

		private static MemberOrder GetMemberOrder(MemberInfo memberInfo) =>
			memberInfo switch
			{
				TypeInfo => MemberOrder.Type,
				ConstructorInfo => MemberOrder.Constructor,
				PropertyInfo propertyInfo => GetPropertyOrder(propertyInfo),
				EventInfo eventInfo => GetEventOrder(eventInfo),
				MethodInfo methodInfo => GetMethodOrder(methodInfo),
				FieldInfo fieldInfo => GetFieldOrder(fieldInfo),
				_ => MemberOrder.Unknown,
			};

		private static MemberOrder GetPropertyOrder(PropertyInfo propertyInfo)
		{
			var method = propertyInfo.GetMethod ?? propertyInfo.SetMethod;
			if (!method.IsStatic)
				return MemberOrder.InstanceProperty;
			if (propertyInfo.PropertyType == propertyInfo.DeclaringType)
				return MemberOrder.LifetimeProperty;
			return MemberOrder.StaticProperty;
		}

		private static MemberOrder GetEventOrder(EventInfo eventInfo)
		{
			var method = eventInfo.AddMethod ?? eventInfo.RemoveMethod;
			if (!method.IsStatic)
				return MemberOrder.InstanceEvent;
			return MemberOrder.StaticEvent;
		}

		private static MemberOrder GetMethodOrder(MethodInfo methodInfo)
		{
			if (methodInfo.Name.StartsWith("op_", StringComparison.Ordinal))
				return MemberOrder.Operator;
			if (!methodInfo.IsStatic)
				return MemberOrder.InstanceMethod;
			if (methodInfo.ReturnType == methodInfo.DeclaringType)
				return MemberOrder.LifetimeMethod;
			return MemberOrder.StaticMethod;
		}

		private static MemberOrder GetFieldOrder(FieldInfo fieldInfo)
		{
			if (!fieldInfo.IsStatic)
				return MemberOrder.InstanceField;
			if (fieldInfo.FieldType == fieldInfo.DeclaringType)
				return MemberOrder.LifetimeField;
			return MemberOrder.StaticField;
		}

		private static IEnumerable<T> OrderMembers<T>(IEnumerable<T> items, Func<T, MemberInfo> getMemberInfo)
		{
			return items.OrderBy(x => (int) GetMemberOrder(getMemberInfo(x)))
				.ThenBy(x => GetShortName(getMemberInfo(x)).ToString(), StringComparer.OrdinalIgnoreCase)
				.ThenBy(x => GetGenericArguments(getMemberInfo(x)).Length)
				.ThenBy(x => GetParameters(getMemberInfo(x)).Length)
				.ThenBy(x => GetParameterShortNames(getMemberInfo(x)), StringComparer.OrdinalIgnoreCase);
		}

		private static MethodInfo? TryGetDelegateInvoke(MemberInfo memberInfo)
		{
			var typeInfo = memberInfo as TypeInfo;
			return typeInfo != null && typeof(Delegate).GetTypeInfo().IsAssignableFrom(typeInfo) ? typeInfo.DeclaredMethods.FirstOrDefault(x => x.Name == "Invoke") : null;
		}

		private static Type[] GetGenericArguments(MemberInfo memberInfo)
		{
			var type = memberInfo as TypeInfo;
			if (type != null)
				return type.GenericTypeParameters;

			var method = memberInfo as MethodInfo;
			return method?.GetGenericArguments() ?? Array.Empty<Type>();
		}

		private static ParameterInfo[] GetParameters(MemberInfo memberInfo)
		{
			var delegateInvoke = TryGetDelegateInvoke(memberInfo);
			if (delegateInvoke != null)
				return GetParameters(delegateInvoke);

			var propertyInfo = memberInfo as PropertyInfo;
			if (propertyInfo != null)
				return propertyInfo.GetIndexParameters();

			var method = memberInfo as MethodBase;
			return method?.GetParameters() ?? Array.Empty<ParameterInfo>();
		}

		private static string GetParameterShortNames(MemberInfo memberInfo) =>
			string.Join(", ", GetParameters(memberInfo).Select(x => RenderTypeName(x.ParameterType.GetTypeInfo())));

		private static bool IsLessDerived(TypeInfo a, TypeInfo b)
		{
			if (!a.IsAssignableFrom(b))
				return false;
			if (a.IsGenericType && b.IsGenericType && a.GetGenericTypeDefinition().GetTypeInfo() == b.GetGenericTypeDefinition().GetTypeInfo())
			{
				var parameters = a.GetGenericTypeDefinition().GetTypeInfo().GenericTypeParameters;
				for (var i = 0; i < parameters.Length; i++)
				{
					var paramAttributes = parameters[i].GetTypeInfo().GenericParameterAttributes;
					var aArgInfo = a.GenericTypeArguments[i].GetTypeInfo();
					var bArgInfo = b.GenericTypeArguments[i].GetTypeInfo();
					if (paramAttributes.HasFlag(GenericParameterAttributes.Contravariant) && !aArgInfo.IsAssignableFrom(bArgInfo))
						return false;
					if (paramAttributes.HasFlag(GenericParameterAttributes.Covariant) && aArgInfo.IsAssignableFrom(bArgInfo))
						return false;
				}
			}
			return true;
		}

		private static bool IsKeyword(string value) => s_keywords.Contains(value);

		private string ToMarkdown(XmlDocInline inline, MarkdownContext context)
		{
			var text = inline.Text ?? "";

			MemberInfo? seeMemberInfo = null;
			if (inline.SeeRef != null)
				context.MembersByXmlDocName.TryGetValue(inline.SeeRef, out seeMemberInfo);

			if (text.Length == 0)
			{
				if (seeMemberInfo != null)
					text = GetOperatorKeywordName(GetShortName(seeMemberInfo));
				else if (inline.SeeRef != null)
					text = XmlDocUtility.GetShortNameForXmlDocRef(inline.SeeRef);
				else if (inline.LinkUrl != null)
					text = inline.LinkUrl;
				else if (inline.LangWord != null)
					text = SurroundCode(inline.LangWord);
			}

			if (text.Length != 0)
			{
				var isCode = inline.IsCode || seeMemberInfo != null;
				if (isCode)
					text = SurroundCode(text);

				if (inline.IsParamRef || inline.IsTypeParamRef)
					text = $"*{text}*";

				text = WrapMarkdownRefLink(text, seeMemberInfo, context, isCode: inline.IsCode, linkUrl: inline.LinkUrl);
			}

			text = Regex.Replace(text, @"\s+", " ");

			return text;
		}

		private string WrapMarkdownRefLink(string text, MemberInfo? memberInfo, MarkdownContext context, bool isCode = false, string? linkUrl = null)
		{
			var extension = GetFileExtension();
			var xmlDocRef = memberInfo == null ? null : XmlDocUtility.GetXmlDocRef(memberInfo);
			var isLocal = xmlDocRef != null && context.MembersByXmlDocName.ContainsKey(xmlDocRef);
			var externalDoc = isLocal || xmlDocRef == null ? null : FindExternalDocumentation(memberInfo);
			if (memberInfo != null && xmlDocRef != XmlDocUtility.GetXmlDocRef(context.MemberInfo) && (isLocal || externalDoc != null))
			{
				string path;

				var typeInfo = memberInfo as TypeInfo;
				if (context.MemberInfo != null)
				{
					if (typeInfo != null)
						path = $"{GetNamespaceUriName(typeInfo.Namespace)}/{GetSafeTypeUriName(typeInfo)}{extension}";
					else
						path = $"{GetNamespaceUriName(memberInfo.DeclaringType?.Namespace)}/{GetTypeUriName(memberInfo.DeclaringType.GetTypeInfo())}/{GetMemberUriName(memberInfo)}{extension}";
				}
				else if (context.TypeInfo != null)
				{
					if (typeInfo != null)
						path = $"{GetNamespaceUriName(typeInfo.Namespace)}/{GetSafeTypeUriName(typeInfo)}{extension}";
					else
						path = $"{GetNamespaceUriName(memberInfo.DeclaringType?.Namespace)}/{GetTypeUriName(memberInfo.DeclaringType.GetTypeInfo())}/{GetMemberUriName(memberInfo)}{extension}";
				}
				else
				{
					if (typeInfo != null)
						path = $"{GetNamespaceUriName(typeInfo.Namespace)}/{GetSafeTypeUriName(typeInfo)}{extension}";
					else
						path = $"{GetNamespaceUriName(memberInfo.DeclaringType?.Namespace)}/{GetTypeUriName(memberInfo.DeclaringType.GetTypeInfo())}/{GetMemberUriName(memberInfo)}{extension}";
				}

				if (!string.IsNullOrEmpty(context.PageLocation))
					path = MakeRelative(context.PageLocation, path);

				text = $"[{text}]({path})";
			}
			else if (linkUrl != null)
			{
				text = $"[{text}]({linkUrl})";
			}

			return isCode ? text : EscapeHtml(text);
		}

		private string MakeRelative(string baseUri, string path)
		{
			var a = new Uri("file:///" + baseUri);
			var b = new Uri("file:///" + path);
			var rel = a.MakeRelativeUri(b);
			var result = rel.ToString();
			if (string.IsNullOrEmpty(result))
			{
				// then the file name is the link
				result = b.Segments.Last();
			}

			// generate explicit relative link, e.g. for GitLab wiki
			return result[0] == '.' ? result : $"./{result}";
		}

		private string? ToMarkdown(IEnumerable<XmlDocInline>? inlines, MarkdownContext context) =>
			inlines == null ? null : string.Concat(inlines.Select(x => ToMarkdown(x, context))).Trim();

		private IEnumerable<string> ToMarkdown(IReadOnlyList<XmlDocBlock> blocks, MarkdownContext context)
		{
			for (var index = 0; index < blocks.Count; index++)
			{
				if (index != 0)
					yield return "";

				var block = blocks[index];

				if (block.ListKind == XmlDocListKind.Bullet || block.ListKind == XmlDocListKind.Number)
				{
					var number = 0;
					while (true)
					{
						var prefix = new string(' ', block.ListDepth * 2) + (block.ListKind == XmlDocListKind.Number ? $"{++number}. " : "* ");
						var markdown = ToMarkdown(block.Inlines, context);

						if (block.IsListTerm)
						{
							markdown = $"**{markdown}**";

							var afterTermBlock = index + 1 < blocks.Count ? blocks[index + 1] : null;
							if (afterTermBlock != null && afterTermBlock.ListKind == block.ListKind && afterTermBlock.ListDepth == block.ListDepth && !afterTermBlock.IsListTerm)
							{
								markdown += " – " + ToMarkdown(afterTermBlock.Inlines, context);
								index++;
							}
						}

						yield return prefix + markdown;

						var nextBlock = index + 1 < blocks.Count ? blocks[index + 1] : null;
						if (nextBlock == null || nextBlock.ListKind != block.ListKind)
							break;

						block = nextBlock;
						index++;
					}
				}
				else
				{
					if (block.IsCode)
					{
						yield return "``` " + block.CodeLanguage;
						foreach (var inline in block.Inlines)
							yield return inline.Text!.Replace(Environment.NewLine, ActualNewLine);
						yield return "```";
					}
					else
					{
						var markdown = ToMarkdown(block.Inlines, context)!;
						if (block.IsListHeader || block.IsListTerm)
							markdown = $"**{markdown}**";
						yield return markdown;
					}
				}
			}
		}

		private class MarkdownContext
		{
			public MarkdownContext(XmlDocAssembly xmlDocAssembly, IReadOnlyDictionary<string, MemberInfo> membersByXmlDocName, string assemblyFileName, string? sourceCodePath, string rootNamespace, string pageLocation)
			{
				XmlDocAssembly = xmlDocAssembly;
				MembersByXmlDocName = membersByXmlDocName;
				AssemblyFileName = assemblyFileName;
				SourceCodePath = sourceCodePath;
				RootNamespace = rootNamespace;
				PageLocation = pageLocation;
			}

			public MarkdownContext(MarkdownContext context, MemberInfo? memberInfo, string pageLocation)
			{
				XmlDocAssembly = context.XmlDocAssembly;
				MembersByXmlDocName = context.MembersByXmlDocName;
				AssemblyFileName = context.AssemblyFileName;
				SourceCodePath = context.SourceCodePath;
				RootNamespace = context.RootNamespace;
				PageLocation = pageLocation;

				var typeInfo = memberInfo as TypeInfo;
				if (typeInfo != null)
				{
					TypeInfo = typeInfo;
				}
				else if (memberInfo != null)
				{
					TypeInfo = memberInfo.DeclaringType.GetTypeInfo();
					MemberInfo = memberInfo;
				}
			}

			public TypeInfo? TypeInfo { get; }

			public MemberInfo? MemberInfo { get; }

			public XmlDocAssembly XmlDocAssembly { get; }

			public IReadOnlyDictionary<string, MemberInfo> MembersByXmlDocName { get; }

			public string AssemblyFileName { get; }

			public string? SourceCodePath { get; }

			public string RootNamespace { get; }

			public string PageLocation { get; }
		}

		private static readonly HashSet<string> s_keywords = new()
		{
			"abstract",
			"as",
			"base",
			"bool",
			"break",
			"byte",
			"case",
			"catch",
			"char",
			"checked",
			"class",
			"const",
			"continue",
			"decimal",
			"default",
			"delegate",
			"do",
			"double",
			"else",
			"enum",
			"event",
			"explicit",
			"extern",
			"false",
			"finally",
			"fixed",
			"float",
			"for",
			"foreach",
			"goto",
			"if",
			"implicit",
			"in",
			"int",
			"interface",
			"internal",
			"is",
			"lock",
			"long",
			"namespace",
			"new",
			"null",
			"object",
			"operator",
			"out",
			"override",
			"params",
			"private",
			"protected",
			"public",
			"readonly",
			"ref",
			"return",
			"sbyte",
			"sealed",
			"short",
			"sizeof",
			"stackalloc",
			"static",
			"string",
			"struct",
			"switch",
			"this",
			"throw",
			"true",
			"try",
			"typeof",
			"uint",
			"ulong",
			"unchecked",
			"unsafe",
			"ushort",
			"using",
			"virtual",
			"void",
			"volatile",
			"while",
		};
	}
}
